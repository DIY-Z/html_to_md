# 21. django关闭浏览器，怎样清除 cookies 和 session？
设置Cookie
```python
1. def cookie_set(request): 
2.     response = HttpResponse("<h1>设置Cookie，请查看响应报文头</h1>") 
3.     response.set_cookie('h1', 'hello django') 
4.     return response 
```
读取Cookie
```python
1. def cookie_get(request):  
2.     response = HttpResponse("读取Cookie，数据如下：<br>") 
3.     if request.COOKIES.has_key('h1'): 
4.         response.write('<h1>' + request.COOKIES['h1'] + '</h1>') 
5.     return response 
```
以键值对的格式写会话。
```python
1. request.session['键']=值 
```
根据键读取值。
```python
1. request.session.get('键',默认值) 
```
清除所有会话，在存储中删除值部分。
```python
1. request.session.clear() 
```
清除会话数据，在存储中删除会话的整条数据。
```python
1. request.session.flush() 
```
删除会话中的指定键及值，在存储中只删除某个键及对应的值。
```python
1. del request.session['键'] 
```
设置会话的超时时间，如果没有指定过期时间则两个星期后过期。<br />
如果value是一个整数，会话将在value秒没有活动后过期。<br />
如果value为0，那么用户会话的Cookie将在用户的浏览器关闭时过期。<br />
如果value为None，那么会话在两周后过期。
```python
1. request.session.set_expiry(value) 
```
Session 依赖于 Cookie，如果浏览器不能保存 cookie 那么 session 就失效了。因为它需要浏览器的 cookie 值去 session 里做对比。session就是用来在服务器端保存用户的会话状态。<br />
cookie 可以有过期时间，这样浏览器就知道什么时候可以删除 cookie了。 如果 cookie 没有设置过期时间，当用户关闭浏览器的时候，cookie 就自动过期了。你可以改变 SESSION_EXPIRE_AT_BROWSER_CLOSE 的设置来控制session 框架的这一行为。缺省情况下， SESSION_EXPIRE_AT_BROWSER_CLOSE设置为 False ，这样，会话 cookie 可以在用户浏览器中保持有效达SESSION_COOKIE_AGE 秒（缺省设置是两周，即 1，209，600 秒）如果你不想用户每次打开浏览器都必须重新登陆的话，用这个参数来帮你。如果SESSION_EXPIRE_AT_BROWSER_CLOSE<br />
设置为 True，当浏览器关闭时，Django 会使 cookie 失效。<br />
SESSION_COOKIE_AGE：设置 cookie 在浏览器中存活的时间。
# 22. 有用过Django REST framework 吗？
面试就喜欢面试官问这种问题，前面就已经说过了，这种问题一提出来，我们内心是高兴的一笔的，正好将我们学的Django restframework源码带面试官走一波，之后可以再补充一点Django的其他源码，比如ORM源码，settings源码，<br />
admin源码...最后一定要记住，你要展示出你不仅阅读过源码还基于源码在自己的实际项目中参考借鉴过。如果把面试比作考试题满分100的话，这一题就是送分的30分大题！！！
# 23. Celery分布式任务队列？
情景：用户发起request，并等待response返回。在本些views中，可能需要执行一段耗时的程序，那么用户就会等待很长时间，造成不好的用户体验，比如发送邮件、手机验证码等。 使用celery后，情况就不一样了。解决：将耗时的程序放到celery中执行。将多个耗时的任务添加到队列queue中，也就是用redis实现broker中间人，然后用多个worker去监听队列 里的任务去执行。<br />
<img src="https://img-blog.csdnimg.cn/20181108115107579.png" />

- 任务task：就是一个Python函数。
- 队列queue：将需要执行的任务加入到队列中。
- 工人worker：在一个新进程中，负责执行队列中的任务。
- 代理人broker：负责调度，在布置环境中使用redis。<br />
正向代理：请求经过代理服务器从局域网发出，然后到达互联网上的服务器。<br />
特点：服务端并不知道真正的客户端是谁。<br />
反向代理：请求从互联网发出，先进入代理服务器，再转发给局域网内的服务器。<br />
特点：客户端并不知道真正的服务端是谁。<br />
区别：正向代理的对象是客户端。反向代理的对象是服务端。

# 24. 简述Django下的（内建的）缓存机制?
Django提供6种缓存方式:<br />
开发调试<br />
内存<br />
文件<br />
数据库<br />
Memcache缓存(python-memcached模块)<br />
Memcache缓存(pylibmc模块)<br />
除此之外还可使用redis缓存<br />
由于Django是动态网站，所有每次请求均会去数据进行相应的操作，当程序访问量大时，耗时必然会更加明显，<br />
最简单解决方式是使用：缓存，缓存将一个某个views的返回值保存至内存或者memcache中，5分钟内(默认配置)再有人来访问时，<br />
则不再去执行view中的操作，而是直接从内存或者Redis中之前缓存的内容拿到，并返回。<br />
这里可以向面试官介绍一下前面提到的Django中间件配合缓存协同工作的机制
# 25. 对cookie与session的了解？他们能单独用吗？
首先需要搞清楚的是session是存储在服务器上的，cookie是存储在客户端浏览器上的两者是相辅相成的用户首次访问服务器，服务器会为每个用户单独创建一个session对象(HttpSession)，<br />
并为每个session分配唯一一个id(sessionId)，sessionId通过cookie保存到用户端，当用户再次访问服务器时，需将对应的sessionId携带给服务器，服务器通过这个唯一sessionId就可以找到用户对应的session对象，从而达到管理用户状态