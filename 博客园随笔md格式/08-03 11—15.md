# 11. 如何把整个数据库导出来，再导入指定数据库中？
导出：<br />
mysqldump [-h 主机] -u 用户名 -p 数据库名 > 导出的数据库名.sql<br />
导入指定的数据库中:<br />
**第一种方法：**<br />
mysqldump [-h 主机] -u 用户名 -p 数据库名 < 导出的数据库名.sql<br />
**第二种方法：**<br />
先创建好数据库，因为导出的文件里没有创建数据库的语句，如果数据库已经建好，则不用再创建。<br />
create database example charset=utf8;（数据库名可以不一样）<br />
切换数据库：<br />
use example;<br />
导入指定 sql 文件：<br />
mysql>source /path/example.sql;
# 12. Flask和Django路由映射的区别？
在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。在flask中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个url用于不同的作用。
# 13. 跨站请求伪造和跨站请求保护的实现？
<img src="https://img-blog.csdnimg.cn/20181108115517483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbWluaWNKaQ==,size_16,color_FFFFFF,t_70" /><br />
图中Browse是浏览器，WebServerA是受信任网站/被攻击网站A，WebServerB是恶意网站/点<br />
击网站B。<br />
（1）一开始用户打开浏览器，访问受信任网站A，输入用户名和密码登陆请求登陆网站A。<br />
（2）网站A验证用户信息，用户信息通过验证后，网站A产生Cookie信息并返回给浏览器。<br />
（3）用户登陆网站A成功后，可以正常请求网站A。<br />
（4）用户未退出网站A之前，在同一浏览器中，打开一个TAB访问网站B。<br />
（5）网站B看到有人方式后，他会返回一些攻击性代码。<br />
（6）浏览器在接受到这些攻击性代码后，促使用户不知情的情况下浏览器携带Cookie（包括sessionId）信息，请求网站A。这种请求有可能更新密码，添加用户什么的操作。 从上面CSRF攻击原理可以看出，要完成一次CSRF攻击，需要被攻击者完成两个步骤：<br />
1.登陆受信任网站A，并在本地生成COOKIE。<br />
2.在不登出A的情况下，访问危险网站B。<br />
如果不满足以上两个条件中的一个，就不会受到CSRF的攻击，以下情况可能会导致CSRF：<br />
1.登录了一个网站后，打开一个tab页面并访问另外的网站。<br />
2.关闭浏览器了后，本地的Cookie尚未过期，你上次的会话还没有已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）<br />
解决办法：就是在表单中添加from.csrf_token。
# 14. Flask(_ name_ )中的__name__可以传入哪些值？<br />
可以传入的参数：<br />
1，字符串：‘hello’,<br />
但是‘abc’,不行，因为abc是python内置的模块<br />
2，__name__，约定俗成<br />
不可以插入的参数<br />
1，python内置的模块，re,urllib,abc等<br />
2，数字
# 15. 请手写一个 flask 的 Hello World。
```python
from flask import Flask;------->引入Flask插件，pip install Flask;

app=Flask(__name__) #变量app是Flask的一个实例并且必须传入一个参数，__name__对应的值是__main，即当前的py文件的文件名作为Flask的程序名称，这个也可以自定义，比如，取，'MY_ZHH_APP'
                          #__name__是固定写法，主要是方便flask框架去寻找资源 ，也方便flask插件出现错误时，去定位问题

@app.route('/')      #相当于一个装饰器，视图映射，路由系统生成 视图对应url，这边没有指定method .默认使用get
def first_flask():    #视图函数
    return 'Hello World'  #response，最终给浏览器返回的内容


if __name__ == '__main__':
    app.run(debug=True)              #启动这个应用服务器，并开启debug,才能定位问题
```