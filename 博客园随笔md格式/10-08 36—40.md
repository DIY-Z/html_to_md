# 36.mysql 下面那些查询不会使用索引
between, like "c%" , not in, not exists, !=, <, <=, =, >, >=,in
# 37.mysql 中 varchar 与 char 的区别以及 varchar(50)中的 50 代表的含义
```sql
varchar与char的区别char是一种固定长度的类型，varchar则是一种可变长度的类型 
尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间， 
其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

varchar(50)代表的含义：
varchar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，
因为order by col采用fixed_length计算col长度(memory引擎也一样) 
```
# 38.从delete语句中省略where子句,将产生什么后果?
```python
A. delete语句将失败因为没有记录可删除 
B. delete语句将从表中删除所有的记录    *****
C. delete语句将􏰀示用户进入删除的标准 
D. delete语句将失败,因为语法错误 
```
# 39.叙述mysql半同步复制原理
```python
mysql的主备库通过binlog日志保持一致，主库本地执行完事务，binlog日志落盘后即返回给用户；备库通过拉取主库binlog日志来同步主库的操作。默认情况下，主库与备库并没有严格的同步，因此存在一定的概率备库与主库的数据是不对等的。半同步特性的出现，就是为了保证在任何时刻主备数据一致的问题。相对于异步复制，半同步复制要求执行的每一个事务，都要求至少有一个备库成功接收后，才返回给用户。实现原理也很简单，主库本地执行完毕后，等待备库的响应消息(包含最新备库接收到的binlog(file,pos))，接收到备库响应消息后，再返回给用户，这样一个事务才算真正完成。在主库实例上，有一个专门的线程(ack_receiver)接收备库的响应消息，并以通知机制告知主库备库已经接收的日志，可以继续执行。
```
# 40.sql 查询
存在的表有<br />
\1. products(商品表) columns 为 id, name, price<br />
\2. orders(商城订单表) columns 为 id, reservation_id, product_id, quentity(购买数量)<br />
\3. reservations(酒店订单表) columns 为 id,user_id, price, created
需要查询的:
<ol>
- 各个商品的售卖情况, 需要字段 商品名 购买总量 商品收入
- 所有用户在2018-01-01至2018-02-01下单次数,下单金额,商城下单次 数, 商城下单金额
- 历月下单用户数: 下单一次用户数, 下单两次用户数, 下单三次及以上用户 数
</ol>