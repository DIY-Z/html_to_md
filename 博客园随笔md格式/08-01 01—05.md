# 1. Flask 中正则 URL 的实现？
app.route('<URL>')中 URL 显式支持 string、int、float、path uuid any 6种类型，隐式支持正则。<br />
**第一步：**写正则类，继承 BaseConverter，将匹配到的值设置为 regex 的值。
```python
1. class RegexUrl(BaseConverter): 
2.      def __init__(self， url_map， *args): 
3.          super(RegexUrl， self).__init__(url_map) 
4.          self.regex = args[0] 
```
**第二步：**把正则类赋值给我们定义的正则规则。
```python
5. app.url_map.converters['re'] = RegexUrl 
```
**第三步：**在 URL 中使用正则。
```python
6. @app.route('/regex/<re("[a-z]{3}"):id>') 
7. def regex111(id): 
8.    return 'id:%s'%id 
```
# 2. Flask 中请求上下文和应用上下文的区别和作用？
current_app、g 是应用上下文。<br />
request、session 是请求上下文。<br />
手动创建上下文的两种方法：
```python
1. with app.app_context() 
2. app = current_app._get_current_object() 
```
**两者区别：**<br />
请求上下文：保存了客户端和服务器交互的数据。<br />
应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等。<br />
两者作用：<br />
请求上下文(request context)：<br />
Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。请求对象是一个很好的例子，它封装了客户端发送的HTTP请求。<br />
要想让视图函数能够访问请求对象，一个显而易见的方式是将其作为参数传入视图函数，不过这会导致程序中的每个视图函数都增加一个参数，除了访问请求对象,如果视图函数在处理请求时还要访问其他对象，情况会变得更糟。为了避免大量可有可无的参数把视图函数弄得一团糟，<br />
Flask使用上下文临时把某些对象变为全局可访问。<br />
应用上下文(application context)：<br />
它的字面意思是 应用上下文，但它不是一直存在的，它只是request context 中的一个对 app 的代理(人)，所谓local proxy。它的作用主要是帮助 request 获取当前的应用，它是伴 request 而生，随 request 而灭的。
# 3. Flask中数据库设置？
```python
 app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/test' 
```
动态追踪修改设置，如未设置只会提示警告
```python
 app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True 
```
查询时会显示原始SQL语句
```python
 app.config['SQLALCHEMY_ECHO'] = True 
```
<img src="https://img-blog.csdnimg.cn/2018110811320155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbWluaWNKaQ==,size_16,color_FFFFFF,t_70" />
# 4. 常用的SQLAlchemy查询过滤器？
<img src="https://img-blog.csdnimg.cn/20181108115551636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbWluaWNKaQ==,size_16,color_FFFFFF,t_70" />
# 5. 对Flask蓝图(Blueprint)的理解？
**1) 蓝图的定义**<br />
蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。<br />
使用蓝图可以极大地简化大型应用的开发难度，也为 Flask扩展 提供了一种在应用中注册服务的集中式机制。<br />
**2) 蓝图的应用场景**
<ol>
- 把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。
<ol>
- 以 URL 前缀和/或子域名，在应用上注册一个蓝图。 URL 前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）。
- 在一个应用中用不同的 URL 规则多次注册一个蓝图。
- 通过蓝图提供模板过滤器、静态文件、模板和其它功能。一个蓝图不一定要实现应用或者视图函数。
- 初始化一个 Flask 扩展时，在这些情况中注册一个蓝图。<br />
**3) 蓝图的缺点**<br />
不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。<br />
**4) 使用蓝图的三个步骤**<br />
**1.创建 一个蓝图对象**
</ol>
</ol>
```python
 blue = Blueprint("blue"，__name__) 
```
**2.在这个蓝图对象上进行操作 ，例如注册路由、指定静态文件夹、注册模板过滤器**
```python
 @blue.route('/') 
     def blue_index(): 
        return 'Welcome to my blueprint' 
```
**3.在应用对象上注册这个蓝图对象**
```python
 app.register_blueprint(blue，url_prefix='/blue') 
```
字段对象 说明<br />
FieldList 一组指定类型的字段<br />
WTForms常用验证函数<br />
InputRequired 确保字段中有数据<br />
DataRequired 确保字段中有数据并且数据为真<br />
EqualTo 比较两个字段的值，常用于比较两次密码输入<br />
Length 验证输入的字符串长度<br />
NumberRange 验证输入的值在数字范围内<br />
URL 验证URL<br />
AnyOf 验证输入值在可选列表中<br />
NoneOf 验证输入值不在可选列表中<br />
**使用Flask-WTF需要配置参数SECRET_KEY。**<br />
CSRF_ENABLED是为了CSRF（跨站请求伪造）保护。 SECRET_KEY用来生成加密令牌，当CSRF激活的时候，该设置会根据设置的密匙生成加密令牌。