# 16、请实现一个栈。
```python
# 答案:
class Stack(object) :
  def __init__(self,size):
    #类的构造函数
    self.size = size
    self.stack = []

  def __str__(self):
    #类的字符串输出方法，类似于java的.toString()方法
    return str(self.stack)

  def getSize(self) :
    #获取栈当前大小
    return len(self.stack)

  def push(self, x) :
    #入栈，栈满抛异常
    if self.isfull() :
      #return -1
      raise Exception("Stack is full")
    self.stack.append(x)

  def pop(self) :
    #出栈，栈空抛异常
    if self.isempty() :
      #return -1
      raise Exception("Stack is empty")
    topElement = self.stack[-1] 
    self.stack.remove(topElement)
    return topElement

  def isempty(self) :
    #判断栈空
    if len(self.stack) == 0 :
      return True
    return False

  def isfull(self) :
    #判断栈满
    if len(self.stack) == self.size :
      return True
    return False

```
# 17、关于Python类的继承不正确的说法是?(多选)
```python
 A. Python类无法继承
 B. 可以继承, 无法执行父类的构造函数 
 C. 可以有多个父类
 D. 只能有一个父类 
 
 # 答案
 '''
 A
 D
 '''
```
# 18、实现一个hashtable类,对外暴露的有add和get方法,满足以下测试代码
```python
def test():
    import uuid
    names = {"name", "web", "python"}
    ht = HashTable()
    for key in names:
        value = uuid.uuid4()
        ht.add(key, value)
        print("add 元素", key, value)
    for key in names:
        v = ht.get(key)
        print("get 元素", key, v)
 
# 答案:
class HashMap(object):
     def __init__(self):
         # 初始化总表为，容量为2的表格（含两个子表）
         self.maps = BetterMap(2)
         self.num = 0        # 表中数据个数
     
     def get(self,k):        
         return self.maps.get(k)
    
     def add(self, k, v):
         # 若当前元素数量达到临界值（子表总数）时，进行重排操作
         # 对总表进行扩张，增加子表的个数为当前元素个数的两倍！
         if self.num == len(self.maps.maps): 
             self.resize()
         
         # 往重排过后的 self.map 添加新的元素
         self.maps.add(k, v)
         self.num += 1
         
     def resize(self):
         """ 重排操作，添加新表, 注意重排需要线性的时间 """
         # 先建立一个新的表,子表数 = 2 * 元素个数
         new_maps = BetterMap(self.num * 2)
         
         for m in self.maps.maps:  # 检索每个旧的子表
             for k,v in m.items:   # 将子表的元素复制到新子表
                 new_maps.add(k, v)
         
         self.maps = new_maps      # 令当前的表为新表
```
# 19、请用两个队列来实现一个栈(给出伪代码即可)
```python
# 答案:
class StackWithTwoQueues(object):
    #定义两个空队列
    def __init__(self):
        self.queue1 = []
        self.queue2 = []
    #入栈
    def push(self, item):
        self.queue1.append(item)
    #出栈
    def pop(self):
        if len(self.queue1) == 0:
            return(None)
        while(len(self.queue1) != 1):
            self.queue2.append(self.queue1.pop(0))
        self.queue1, self.queue2 = self.queue2, self.queue1
        return (self.queue2.pop())
#test
if __name__ == '__main__':
    ss = StackWithTwoQueues()
    list = [0, 1, 2, 3, 4]
    for i in range(5):
        ss.push(list[i])
    print(list)
    for i in range(5):
        print(ss.pop(), ',', end = '')
#output
#[0, 1, 2, 3, 4]
#4, 3, 2, 1, 0
```
# 20、已知如下链表类,请实现单链表逆置
```python
class Node:
    def __init__(self, value, next):
        self.value = value
        self.next = next

# 答案:
class Solution:
    def ReverseList(self, pHead):
        if not pHead or not pHead.next:
            return pHead
          
        last = None
          
        while pHead:
            tmp = pHead.next
            pHead.next = last
            last = pHead
            pHead = tmp
        return last
```