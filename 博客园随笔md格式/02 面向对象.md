## 1. 简述面向对象的三大特性。
```python
# 答案
封装:
    封装指的是把一堆数据属性与方法数据放在一个容器中，这个容器就是对象。让对象可以通过 "." 来调用对象中的数据属性与方法属性。
    
继承:
    继承指的是子类可以继承父类的数据属性与方法属性，并可以对其进行修改或使用。
    
多态:
    在python中的多态指的是让多种类若具备类似的数据属性与方法属性，都统一好命名规范，这样可以提高开发者的代码统一性，使得调用者更方便去理解。
```
## 2. 什么是鸭子模型?
```python
# 答案
在python中不会强制性要求所有人的代码都统一规范，不统一也不会报错，若使用抽象类就会使python代码强制统一规范，这样不符合python动态语言的特性。所以让大家都自觉统一好规范，若大家的对象方法都类似的话就一种规范，只要长得像鸭子，就称之为鸭子类型。
```
## 3. super 的作用?
```python
# 答案
'''
        使用super()可以在子类中调用父类的方法或属性, 可能你会说, 子类本来就可以调用父类中所有非私有的属性或方法,而我现在说的是, 当子类中实现了某个方法, 父类中也有这个方法, 当你调用这个方法时, 既想执行子类的又想执行父类的, 在这种情况下就可以使用super()
'''
```
## 4. mro 是什么?
```python
# 答案
'''
        mro全称Method Resolution Order，指的是方法解析顺序。
        方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置。而搜索的顺序就是所谓的「方法解析顺序」。
'''
```
## 5. 什么是 c3 算法?
```python
# 答案
'''
C3算法最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。
本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。
单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。
'''
```
## 6. 列举面向对象中带双下划线的特殊方法。
```python
# 答案
#__setattr__: 添加/修改属性会触发它的执行
#__delattr__: 删除属性的时候会触发
#__getattr__: 只有在使用点调用属性且属性不存在的时候才会触发
# __getattribute__: 不管是否存在,我都会执行
```
## 7. 双下划线和单下划线的区别?
```python
# 答案
'''
"单下划线" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量。

"双下划线" 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。
'''
```
## 8. 实例变量和类变量的区别?
```python
# 答案
'''
类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果；而实例变量则属对象私有，某一个对象将其值改变，不影响其他对象；
'''
```
## 9. 静态方法和类方法区别?
```python
# 答案
'''
Python的类就是个语法糖。一个函数写在类里面和写在类外面没有区别，唯一的区别就是参数，所谓实例方法就是第一个参数是self，所谓类方法就是第一个参数是class，而静态方法不需要额外的参数，所以必须区分。
'''
```
## 10. isinstance 和 type 的作用?
```python
# 答案
'''
type和isinstance都可以判断变量是否属于某个内建类型
type只接收一个参数，不但可以判断变量是否属于某个类型，而且可以得到参数变量未知的所属的类型；而isinstance只能判断是否属于某个已知类型，不能直接得到变量未知的所属的类型
'''
```
## 11. 有用过with statement(语句)吗?它的好处是什么?
```python
# 答案
'''
with语句会在嵌套的代码执行之后，自动关闭文件。这种做法的还有另一个优势就是，无论嵌套的代码是以何种方式结束的，它都关闭文件。如果在嵌套的代码中发生异常，它能够在外部exception handler catch异常前关闭文件。如果嵌套代码有return/continue/break语句，它同样能够关闭文件。
'''
```
## 12. 下列数据结构中,哪一种是不可迭代的
```python
'''
    A.  dict
    B.  object
    C.  set
    D.  str
'''

# 答案:
B
```
## 13. 实现一个Singleton单例类,要求遵循基本语言编程规范(用尽量多的方 式)。
```python
# 答案:
1.__new__
class Borg(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            ob = super(Borg, cls)
            cls._instance = ob.__new__(cls, *args, **kwargs)
        return cls._instance
class MyClass(Borg):
    def __init__(self):
        self.a = 1
        
2.共享属性
class Borg2(object):
    _state = {}

    def __new__(cls, *args, **kwargs):
        ob = super(Borg2, cls).__new__(cls, *args, **kwargs)
        ob.__dict__ = cls._state
        return ob

class MyClass(Borg2):
    def __init__(self):
        self.a = 1
        
3.装饰器
def singleton(cls, *args, **kwargs):
    instances = {}

    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return getinstance

@singleton
class MyClass(object):
    def __init__(self):
        self.a = 1

4.import方法
# mysingleton .py
class MyClass(object):
    def __init__(self):
        self.a = 1

s_myclass = MyClass()

from mysingleton import s_myclass

s_myclass.a

```
## 14. 请􏰂述with的用法,如果自己的类需要支持with语句,应该如何书写?
```python
基本格式
with context_expression [as target(s)]:
    with-body

这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 __enter__() 方法的返回值赋值给 target(s)。
target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。

自定义的上下文管理器要实现上下文管理协议所需要的 __enter__() 和 __exit__() 两个方法
context_manager.__enter__() ：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话
context_manager.__exit__(exc_type, exc_value, exc_traceback) ：退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。
```
## 15. python 中如何判断一个对象是否可调用? 哪些对象可以是可调用对象?如何定义一个类，使其对象本身就是可调用对象？
```python
# 答案:
# python 中如何判断一个对象是否可调用
def func():
    pass
print(callable(func))  # True

# 哪些对象可以是可调用对象
1.类对象
2.所有带有_call_()方法的对象

# 如何定义一个类，使其对象本身就是可调用对象
一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法call()。
```
## 16. 请实现一个栈。
```python
# 答案:
class Stack(object) :
  def __init__(self,size):
    #类的构造函数
    self.size = size
    self.stack = []

  def __str__(self):
    #类的字符串输出方法，类似于java的.toString()方法
    return str(self.stack)

  def getSize(self) :
    #获取栈当前大小
    return len(self.stack)

  def push(self, x) :
    #入栈，栈满抛异常
    if self.isfull() :
      #return -1
      raise Exception("Stack is full")
    self.stack.append(x)

  def pop(self) :
    #出栈，栈空抛异常
    if self.isempty() :
      #return -1
      raise Exception("Stack is empty")
    topElement = self.stack[-1] 
    self.stack.remove(topElement)
    return topElement

  def isempty(self) :
    #判断栈空
    if len(self.stack) == 0 :
      return True
    return False

  def isfull(self) :
    #判断栈满
    if len(self.stack) == self.size :
      return True
    return False

```
## 17. 关于Python类的继承不正确的说法是?(多选)
```python
 A. Python类无法继承
 B. 可以继承, 无法执行父类的构造函数 
 C. 可以有多个父类
 D. 只能有一个父类 
 
 # 答案
 '''
 A
 D
 '''

```
## 18. 实现一个hashtable类,对外暴露的有add和get方法,满足以下测试代码
```python
def test():
    import uuid
    names = {"name", "web", "python"}
    ht = HashTable()
    for key in names:
        value = uuid.uuid4()
        ht.add(key, value)
        print("add 元素", key, value)
    for key in names:
        v = ht.get(key)
        print("get 元素", key, v)
 
# 答案:
class HashMap(object):
     def __init__(self):
         # 初始化总表为，容量为2的表格（含两个子表）
         self.maps = BetterMap(2)
         self.num = 0        # 表中数据个数
     
     def get(self,k):        
         return self.maps.get(k)
    
     def add(self, k, v):
         # 若当前元素数量达到临界值（子表总数）时，进行重排操作
         # 对总表进行扩张，增加子表的个数为当前元素个数的两倍！
         if self.num == len(self.maps.maps): 
             self.resize()
         
         # 往重排过后的 self.map 添加新的元素
         self.maps.add(k, v)
         self.num += 1
         
     def resize(self):
         """ 重排操作，添加新表, 注意重排需要线性的时间 """
         # 先建立一个新的表,子表数 = 2 * 元素个数
         new_maps = BetterMap(self.num * 2)
         
         for m in self.maps.maps:  # 检索每个旧的子表
             for k,v in m.items:   # 将子表的元素复制到新子表
                 new_maps.add(k, v)
         
         self.maps = new_maps      # 令当前的表为新表

```
## 19.请用两个队列来实现一个栈(给出伪代码即可)
```python
# 答案:
class StackWithTwoQueues(object):
    #定义两个空队列
    def __init__(self):
        self.queue1 = []
        self.queue2 = []
    #入栈
    def push(self, item):
        self.queue1.append(item)
    #出栈
    def pop(self):
        if len(self.queue1) == 0:
            return(None)
        while(len(self.queue1) != 1):
            self.queue2.append(self.queue1.pop(0))
        self.queue1, self.queue2 = self.queue2, self.queue1
        return (self.queue2.pop())
#test
if __name__ == '__main__':
    ss = StackWithTwoQueues()
    list = [0, 1, 2, 3, 4]
    for i in range(5):
        ss.push(list[i])
    print(list)
    for i in range(5):
        print(ss.pop(), ',', end = '')
#output
#[0, 1, 2, 3, 4]
#4, 3, 2, 1, 0

```
## 20.已知如下链表类,请实现单链表逆置
```python
class Node:
    def __init__(self, value, next):
        self.value = value
        self.next = next

# 答案:
class Solution:
    def ReverseList(self, pHead):
        if not pHead or not pHead.next:
            return pHead
          
        last = None
          
        while pHead:
            tmp = pHead.next
            pHead.next = last
            last = pHead
            pHead = tmp
        return last

```
## 21.类的加载顺序(类中有继承有构造有静态)?
```python
1、 类对象 
2、 实例对象 
3、 self变量名称问题 
4、 类属性、实例变量、局部变量 
5、 类方法 
6、 实例方法 
7、 类方法与实例方法相互调用 
8、 静态方法 
9、 继承时三类方法的影响 

```
## 22.参考下面代码片段
```python
class Context:
    pass

with Context as ctx:
    ctx.do_something()
    
# 请在 Context 类下添加代码完成该类的实现 

# 答案:
class Context(object):
    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        if all([exc_type, exc_val, exc_tb]):
            print 'handler except'
            print 'exception {}'.format(exc_val)
        return True

def main():
    with tornado.stack_context.StackContext(Contextor):
        async_task()

```
## 23. 以下代码输出是什么?请给出答案并解释。
```python
class Parent:
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass
print(Parent.x, Child1.x, Child2.x)
Child1.x = 2
print(Parent.x, Child1.x, Child2.x)
Child1.x = 3
print(Parent.x, Child1.x, Child2.x)

# 答案
'''
1 1 1
1 2 1
1 3 1
'''

```
## 24. 函数del_node(self,data)的功能:在根节点指针为root的二叉树(又称二叉 排序树)上排除数值为 K 的节点,若删除成功,返回 0,否则返回-1, 概述节点的 定义类型为
```python
class Node(object):
    def __init__(self, data):
        self.data = data  # 节点的数值 
        self.left_child = Node  # 指向左右子树的指针 
        self.right_child = Node
        
    def set_data(self, data):
        self.data = data

# 答案: 


```
## 25. 请给出下面代码片段的输出，请简述上面代码需要改进的地方?
```python
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        print("New")
        if cls._instance is None:
            print("Create")
            cls._instance = super().__new__(cls,*args, **kwargs)
        return cls._instance
    def __init__(self):
        print("Initalize")
        self.prop = None

s1 = Singleton()
s2 = Singleton()

# 答案:


```
## 26. 请简单解释Python中的staticmethod(静态方法)和classmethod(类方法), 并将以下代码填写完整。
```python
class A:
    def foo(self, x):
        print('executing class_foo(%s, %s)' % (self, x))

    @classmethod
    def class_foo(cls, x):
        print('executing class_foo(%s, %s)' % (cls, x))

    @staticmethod
    def static_foo(x):
        print('executing static_foo(%s)' % (x))

a = A()
# 调用 foo 函数,参数传入 1
# ____________________
# 调用 class_foo 函数,参数传入 1
# ____________________
# 调用 static_foo 函数,参数传入 1
# ____________________

# 答案:
a.foo(1)
A.class_foo(1)
a.static_foo(1)
A.static_foo(1)

```
## 27.已知一个订单对象(tradeOrder)有如下字段:
<table>
<thead>
<tr class="header">
<th>字段英文名</th>
<th>中 文 名</th>
<th>字段类型</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Id</td>
<td>主 键</td>
<td>Long</td>
<td>123456789</td>
</tr>
<tr class="even">
<td>Name</td>
<td>姓 名</td>
<td>String</td>
<td>张三</td>
</tr>
<tr class="odd">
<td>Items</td>
<td>商 品 列 表 集 合</td>
<td>List<商品> (关联商 品)</td>
<td>`查找商品对象，一 个订单有两个商 品。商品字段任意 取值。`</td>
</tr>
<tr class="even">
<td>IsMember</td>
<td>是 否 是 会 员</td>
<td>Boolean</td>
<td>True</td>
</tr>
<tr class="odd">
<td>CouponAmount</td>
<td>优 惠 券 金 额</td>
<td>Bigdecimal</td>
<td>Null</td>
</tr>
</tbody>
</table>
​ 商品对象
<table>
<thead>
<tr class="header">
<th>字段英文名称</th>
<th>中文名</th>
<th>字段类型</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Id</td>
<td>主键</td>
<td>Long</td>
<td>987654321</td>
</tr>
<tr class="even">
<td>Name</td>
<td>商品名称</td>
<td>String</td>
<td>手机</td>
</tr>
</tbody>
</table>
​ 问题: 若将订单对象转成 JSON 格式，请书写出转换后的 JSON 字符串。
## 28. 写代码(栈与队列)
​ 编程实现一个先进先出的队列类, 能指定初始化时的队列大小, 以及 enqueue,dequeue,is empty, is full 四种方法
​ 使用方法如下
```python
s = Queue(2)  # 初始化一个大小为 2 的队列
s.is_empty()  # 初始化后, 队列为空, 返回 True
s.enqueue(1)  # 将 1 加入队列
s.enqueue(2)  # 将 2 加入队列
s.isfull()  # 加入了两个元素, 队列已满, 返回 True 6. s.dequeue() # 移除一个元素, 返回 1
s.dequeue()  # 移除一个元素, 返回 2
s.is_empty()  # 队列已经为空, 返回 True

```