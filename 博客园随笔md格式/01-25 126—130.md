# 81、求打印结果
```python
arr = [1,2,3]
def bar():
     arr+=[5]

     bar()
print(arr)
'''
A.  error
B.  [5]
C. [1,2,3]
D. [1,2,3,5]
'''
# 答案
A
```
# 82、请给出下面代码片段的输出
```python
def say_hi(func):
    def wrapper(*args, **kwargs):
        print("HI")
        ret = func(*args, **kwargs)
        print("BYE")
        return re
    return wrapper

def say_yo(func):
    def wrapper(*args, **kwargs):
        print("YO")
        return func(*args, **kwargs)
    return wrapper

@say_hi
@say_yo
def func():
    print("ROCK &amp; ROLL")
func()

# 答案
'''
HI
YO
ROCK &amp; ROLL
BYE
'''
```
# 83、map(str,[1,2,3,4,5,6,7,8,9]) 输出是什么?
```python
print(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))  # <map object at 0x101f59748>
```
# 84、请简述标准库中functools.wraps的作用
```python
# 答案
'''
Python装饰器（decorator）在实现的时候，有一些细节需要被注意。例如，被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变）。这样有时候会对程序造成一些不便，例如笔者想对flask框架中的一些函数添加自定义的decorator，添加后由于函数名和函数的doc发生了改变，对测试结果有一些影响。

所以，Python的functools包中提供了一个叫wraps的decorator来消除这样的副作用。写一个decorator的时候，最好在实现之前加上functools的wrap，它能保留原有函数的名称和docstring。
'''
```
# 85、请给出下面代码片段的输出
```python
def test():
     try:
            raise ValueError("something wrong")
     except ValueError as e:
            print("Error occurred")
            return
     finally:
            print("Done")
            
test()

# 答案
Error occurred
Done
```