## 66.并行（parallel）和并发（concurrency）？
```
并行：同一时刻多个任务同时在运行。
并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况。
实现并行的库有：multiprocessing
实现并发的库有：threading
程序需要执行较多的读写、请求和回复任务的需要大量的 IO 操作，IO密集型操作使用并发更好。

CPU运算量大的程序程序，使用并行会更好。
IO密集型和CPU密集型区别？
IO密集型：系统运作，大部分的状况是CPU在等 I/O (硬盘/内存)的读/写。
CPU密集型：大部份时间用来做计算、逻辑判断等 CPU动作的程序称之CPU密集型。
```
## 67.使用udp发送/接收数据步骤：
1.创建客户端套接字<br />
2.发送/接收数据<br />
3.关闭套接字
```python
import socket
def main():
    # 1、创建udp套接字
    # socket.AF_INET  表示IPv4协议  AF_INET6 表示IPv6协议
    # socket.SOCK_DGRAM  数据报套接字，只要用于udp协议
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 2、准备接收方的地址
    # 元组类型  ip是字符串类型   端口号是整型
    dest_addr = ('192.168.113.111', 8888)
    # 要发送的数据
    send_data = "我是要发送的数据"
    # 3、发送数据
    udp_socket.sendto(send_data.encode("utf-8"), dest_addr)
    # 4、等待接收方发送的数据  如果没有收到数据则会阻塞等待，直到收到数据
    # 接收到的数据是一个元组   (接收到的数据, 发送方的ip和端口)
    # 1024  表示本次接收的最大字节数
    recv_data, addr = udp_socket.recvfrom(1024)
    # 5、关闭套接字
    udp_socket.close()
if __name__ == '__main__': 22．    main() 编码的转换
    str -->bytes: encode编码
    bytes--> str: decode()解码
```
## 68.UDP绑定端口号：
1.创建socket套接字<br />
2.绑定端口号<br />
3.接收/发送数据<br />
4.关闭套接字
```python
import socket
def main():
    # 1、创建udp套接字
    # socket.AF_INET  表示IPv4协议  AF_INET6 表示IPv6协议
    # socket.SOCK_DGRAM  数据报套接字，只要用于udp协议
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 2、绑定端口
    # 元组类型  ip一般不写 表示本机的任何的一个ip
    local_addr = ('', 7777)
    udp_socket.bind(local_addr)
    # 3、准备接收方的地址
    # 元组类型  ip是字符串类型   端口号是整型
    dest_addr = ('192.168.113.111', 8888)
    # 要发送的数据
    send_data = "我是要发送的数据"
    # 4、发送数据
    udp_socket.sendto(send_data.encode("utf-8"), dest_addr)
    # 5、等待接收方发送的数据  如果没有收到数据则会阻塞等待，直到收到数据
    # 接收到的数据是一个元组   (接收到的数据, 发送方的ip和端口)
    # 1024  表示本次接收的最大字节数
    recv_data, addr = udp_socket.recvfrom(1024)
    # 6、关闭套接字
    udp_socket.close()
if __name__ == '__main__':
    main() 注意点：绑定端口要在发送数据之前进行绑定。
```
## 69.TCP客户端的创建流程：
1.创建TCP的socket套接字<br />
2.连接服务器<br />
3.发送数据给服务器端<br />
4.接收服务器端发送来的消息<br />
5.关闭套接字
```python
import socket
def main():
    # 1、创建客户端的socket
    # socket.AF_INET  表示IPv4协议  AF_INET6 表示IPv6协议
    # socket.SOCK_STREAM  流式套接字，只要用于TCP 协议
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 2、构建目标地址
    server_ip = input("请输入服务器端的IP地址：")
    server_port = int(input("请输入服务器端的端口号："))
    # 3、连接服务器
    # 参数：元组类型   ip 是字符串类型   端口号是整型
    client_socket.connect((server_ip, server_port))
    # 要发送给服务器端的数据
    send_data = "我是要发送给服务器端的数据"
    # 4、发送数据
    client_socket.send(send_data.encode("gbk"))
    # 5、接收服务器端恢复的消息， 没有消息会阻塞
    # 1024表示接收的最大字节数
    recv_date= client_socket.recv(1024)
    print("接收到的数据是：", recv_date.decode('gbk'))
    # 6、关闭套接字
    client_socket.close()
if __name__ == '__main__':
    main()
```
## 70.TCP服务器端的创建流程
1.创建TCP服务端的socket<br />
2.bing绑定ip地址和端口号<br />
3.listen使套接字变为被动套接字<br />
4.accept取出一个客户端连接，用于服务<br />
5.recv/send接收和发送消息<br />
6.关闭套接字
```python
import socket
def main():
    # 1、创建tcp服务端的socket
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 2、绑定
    server_socket.bind(('', 8888))
    # 3、listen使套接字变为被动套接字
    server_socket.listen(128)
    # 4、如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
    # client_socket用来为这个客户端服务
    # tcp_server_socket就可以省下来专门等待其他新客户端的链接
    client_socket, client_addr = server_socket.accept()
    # 5、接收客户端发来的消息
    recv_data = client_socket.recv(1024)
    print("接收到客户端%s的数据：%s" % (str(client_addr), recv_data.decode('gbk')))
    # 6、回复数据给客户端
    client_socket.send("收到消息".encode('gbk'))
    # 7、关闭套接字
    client_socket.close()
    server_socket.close()
if __name__ == '__main__':
    main()
```