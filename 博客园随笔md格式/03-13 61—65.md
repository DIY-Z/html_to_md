## 61.什么是线程安全，什么是互斥锁？
```
每个对象都对应于一个可称为" 互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
同一个进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，
另一个线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。
```
## 62.说说下面几个概念：同步，异步，阻塞，非阻塞?
```
同步：多个任务之间有先后顺序执行，一个执行完下个才能执行。
异步：多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！
阻塞：如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。
非阻塞：如果不会卡住，可以继续执行，就是说非阻塞的。
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。
```
## 63.什么是僵尸进程和孤儿进程？怎么避免僵尸进程?
```
孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程(进程号为 1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用 wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。

避免僵尸进程的方法：
-fork两次用孙子进程去完成子进程的任务；
-用wait()函数使父进程阻塞；
-使用信号量，在 signal handler 中调用waitpid，这样父进程不用阻塞。
```
## 64.Python中的进程与线程的使用场景?
```
多进程适合在 CPU 密集型操作(cpu 操作指令比较多，如位数多的浮点运算)。
多线程适合在 IO 密集型操作(读写数据操作较多的，比如爬虫)。
```
## 65.线程是并发还是并行，进程是并发还是并行？
```
线程是并发，进程是并行；
进程之间相互独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。
```