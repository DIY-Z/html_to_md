# 131、下面这段代码的输出结果将是什么？请解释。
```python
def multipliers():
    return [lambda x : i * x for i in range(4)]
    print [m(2) for m in multipliers()]
```
上面代码输出的结果是[6， 6， 6， 6] (不是我们想的[0， 2， 4， 6])。<br />
上述问题产生的原因是Python闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内<br />
进行查找。因此，当任何由multipliers()返回的函数被调用时， i的值将在附近的范围进行查找。那时，<br />
不管返回的函数是否被调用，for循环已经完成，i被赋予了最终的值3。<br />
因此，每次返回的函数乘以传递过来的值3，因为上段代码传过来的值是2，它们最终返回的都是6。下面是解决这一问题的一些方法。<br />
一种解决方法就是用Python生成器。
```python
def multipliers():
for i in range(4): yield lambda x :
i * x
```
另外一个解决方案就是创造一个闭包，利用默认函数立即绑定。
```python
def  multipliers():
    return [lambda x， i=i : i * x for i in range(4)]
```
# 132、什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和？
```python
"""
lambda 函数是匿名函数；使用 lambda 函数能创建小型匿名函数。这种函数得名于省略了用 def
声明函数的标准步骤；
"""

# 答案
f = lambda x，y:x+y
print(f(2017，2018))
```
# 133、说说python中装饰器、迭代器的用法；描述下dict的items()方法与iteritems()方法的不同；
```python
# 答案
'''
装饰器是指对函数执行过程，做一些扩展，甚至可以更改本身函数的执行迭代器是指遵循迭代器协议的对象，这类对象在被for循环时，每次迭代生成下一个项，不用一开始就生成整个列表在python3中不存在iteritems，items方法返回可迭代对象在python2中items()返回[(key,value)]的列表对象，iteritems()返回迭代器对象，iteritems()循环时不可以增删dict的内容
'''
```
# 134、def(a, b=[])这种写法有什么陷阱?
```python
# 答案
'''
函数的第二个默认参数是一个list，当第一次执行的时候实例化了一个list，第二次执行还是用第一次执行的时候实例化的地址存储，所以三次执行的结果就是 [1, 1, 1] ，想每次执行只输出[1] ，默认参数应该设置为None。
'''
```
# 135、如何判断一个值是函数还是方法?
```python
from types import MethodType,FunctionType

print(isinstance('1', FunctionType))  # False
print(isinstance(lambda x:x, FunctionType))  # True
```