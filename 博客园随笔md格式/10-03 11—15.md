# 11. 你用的Mysql是哪个引擎，各引擎之间有什么区别？
主要 MyISAM 与 InnoDB 两个引擎，其主要区别如下：<br />
InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM就不可以了；<br />
MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；<br />
InnoDB 支持外键，MyISAM 不支持；<br />
MyISAM 是默认引擎，InnoDB 需要指定；<br />
InnoDB 不支持 FULLTEXT 类型的索引；<br />
InnoDB 中不保存表的行数，如 select count() from table 时，InnoDB；需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count()语句包含 where 条件时 MyISAM 也需要扫描整个表；<br />
对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM表中可以和其他字段一起建立联合索引；清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；<br />
InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'
# 12. 数据库的优化？
1.优化索引、SQL 语句、分析慢查询；<br />
2.设计表的时候严格根据数据库的设计范式来设计数据库；<br />
3.使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘IO<br />
4.优化硬件；采用SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等<br />
5.采用MySQL 内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率；<br />
6.垂直分表；把一些不经常读的数据放在一张表里，节约磁盘I/O；<br />
7.主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来；<br />
8.分库分表分机器（数据量特别大），主要的的原理就是数据路由；<br />
9.选择合适的表引擎，参数上的优化<br />
10.进行架构级别的缓存，静态化和分布式；<br />
11.不采用全文索引；<br />
12.采用更快的存储方式，例如 NoSQL存储经常访问的数据**。
# 13. Mysql数据库如何分区、分表？
分表可以通过三种方式：Mysql集群、自定义规则和merge存储引擎。<br />
分区有四类：<br />
RANGE 分区：基于属于一个给定连续区间的列值，把多行分配给分区。<br />
LIST 分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个<br />
值来进行选择。<br />
HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的<br />
这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br />
KEY 分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器<br />
提供其自身的哈希函数。必须有一列或多列包含整数值。
# 14. Sql注入是如何产生的，如何防止？
程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量<br />
POST和GET提交一些sql语句正常执行。产生Sql注入。下面是防止办法：
a. 过滤掉一些常见的数据库操作关键字，或者通过系统函数来进行过滤。
b. 在PHP配置文件中将Register_globals=off;设置为关闭状态
c. SQL语句书写的时候尽量不要省略小引号(tab键上面那个)和单引号
d. 提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的
e. 对于常用的方法加以封装，避免直接暴漏SQL语句
f. 开启PHP安全模式：Safe_mode=on;
g. 打开magic_quotes_gpc来防止SQL注入
h. 控制错误信息：关闭错误提示信息，将错误信息写到系统日志。
i. 使用mysqli或pdo预处理。
# 15. NoSQL和关系数据库的区别？
a. SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。
b. 在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。
c. SQL中如果需要增加外部关联数据的话，规范化做法是在原表中增加一个外键，关联外部数据表。而在NoSQL中除了这种规范化的外部数据表做法以外，我们还能用如下的非规范化方式把外部数据直<br />
接放到原数据集中，以提高查询效率。缺点也比较明显，更新审核人数据的时候将会比较麻烦。
d. SQL 中可以使用JOIN表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。NoSQL暂未提供类似JOIN的查询方式对多个数据集中的数据做查询。所以大部分NoSQL使用非规范化的数据存储方式存储数据。
e. SQL中不允许删除已经被使用的外部数据，而NoSQL中则没有这种强耦合的概念，可以随时删除任何数据。
f. SQL中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成功。这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。而NoSQL中没有事务这个概念，每一个数据集的操作都是原子级的。
g. 在相同水平的系统设计的前提下，因为NoSQL中省略了JOIN查询的消耗，故理论上性能上是优于SQL的。