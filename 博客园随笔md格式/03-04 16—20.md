## 16.threading.local的作用?
```python
# 答案:
为每个线程创建一个独立的空间，使得线程对自己的空间中的数据进行操作（数据隔离）。
import threading
from threading import local
import time
 
obj = local()
 
 
def task(i):
    obj.xxxxx = i
    time.sleep(2)
    print(obj.xxxxx,i)
 
for i in range(10):  #开启了10个线程
    t = threading.Thread(target=task,args=(i,))
    t.start()
```
## 17.进程之间如何进行通信?
```python
# 答案:
python提供了多种进程通信的方式，主要Queue和Pipe这两种方式，Queue用于多个进程间实现通信，Pipe是两个进程的通信。

# Queue
from multiprocessing import Process, Queue
import os,time,random

#写数据进程执行的代码
def proc_write(q,urls):
    print 'Process is write....'
    for url in urls:
        q.put(url)
        print 'put %s to queue... ' %url
        time.sleep(random.random())

#读数据进程的代码
def proc_read(q):
    print('Process is reading...')
    while True:
        url = q.get(True)
        print('Get %s from queue' %url)

if __name__ == '__main__':
    #父进程创建Queue，并传给各个子进程
    q = Queue()
    proc_write1 = Process(target=proc_write,args=(q,['url_1','url_2','url_3']))
    proc_write2 = Process(target=proc_write,args=(q,['url_4','url_5','url_6']))
    proc_reader = Process(target=proc_read,args=(q,))
    #启动子进程，写入
    proc_write1.start()
    proc_write2.start()

    proc_reader.start()
    #等待proc_write1结束
    proc_write1.join()
    proc_write2.join()
    #proc_raader进程是死循环，强制结束
    proc_reader.terminate()




# PIPE
import multiprocessing
import os,time,random

#写数据进程执行的代码
def proc_send(pipe,urls):
    #print 'Process is write....'
    for url in urls:

        print 'Process is send :%s' %url
        pipe.send(url)
        time.sleep(random.random())

#读数据进程的代码
def proc_recv(pipe):
    while True:
        print('Process rev:%s' %pipe.recv())
        time.sleep(random.random())

if __name__ == '__main__':
    #父进程创建pipe，并传给各个子进程
    pipe = multiprocessing.Pipe()
    p1 = multiprocessing.Process(target=proc_send,args=(pipe[0],['url_'+str(i) for i in range(10) ]))
    p2 = multiprocessing.Process(target=proc_recv,args=(pipe[1],))
    #启动子进程，写入
    p1.start()
    p2.start()

    p1.join()
    p2.terminate()

```
## 18.什么是并发和并行?
```python
# 答案:
# 并发：同一时刻只能处理一个任务，但可以交替处理多个任务。(一个处理器同时处理多个任务)
# 并行：同一时刻可以处理多个任务。(多个处理器或者是多核的处理器同时处理多个不同的任务)
# 类比：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 

```
## 19.同步和异步，阻塞和非阻塞的区别？
```python
# 答案:
'''
同步：执行一个操作之后，需要主动等待返回结果；
异步：执行一个操作之后，不需要主动等待返回结果，若接收到结果通知，再回来执行刚才没执行完的操作。
同步和异步关心的问题是：要不要主动等待结果。

阻塞：在执行一个操作时，不能做其他操作；
非阻塞：在执行一个操作时，能做其他操作。
阻塞和非阻塞关心的问题是：能不能做其他操作。
'''
```
## 20.路由器和交换机的区别?
```python
# 答案:
'''
1：交换机：是负责内网里面的数据传递（arp协议）根据MAC地址寻址。
   路由器：在网络层，路由器根据路由表，寻找该ip的网段。
2：路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。
   交换机可以把很多主机连起来，这些主机对外各有各的IP。
3：交换机是做端口扩展的，也就是让局域网可以连进来更多的电脑。
   路由器是用来做网络连接，也就是连接不同的网络。
'''

```