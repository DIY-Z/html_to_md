# 36、有一个list["This","is","a","Boy","!"],所有元素都是字符串,对他进行大小写 无关的排序
```python
l1 = ['This','is','a','Boy','!']
print(sorted(l1))
```
# 37、列举字符串、列表、元组、字典每个常用的5个方法?
```python
字符串：repleace,strip,split,reverse,upper,lower,join.....

列表：append,pop,insert,remove,sort,count,index.....

元组：index,count,len(),dir()

字典：get,keys,values,pop,popitems,clear,update,items.....
```
# 38、什么是反射?以及应用场景?
```python
在绝大多数语言当中都有反射机制的存在， 可以用字符串的方式去访问对象的属性，调用对象的方法（但是不能去访问方法），Python中一切皆对象，都可以使用反射

1）、反射机制是很多框架的基石。
2）、
```
# 39、简述Python的深浅拷贝?
```python
copy()：浅copy，浅拷贝指仅仅拷贝数据集合的第一层数据

deepcopy():深copy,深拷贝指拷贝数据集合的所有层
```
# 40、Python 垃圾回收机制?
```python
垃圾回收机制是自动帮助我们管理内存，清理垃圾的一种工具

1）、引用计数
当一个对象的引用被创建或者复制时，对象的引用计数加1；
当一个对象的引用被销毁时，对象的引用计数减1；
当对象的引用计数减少为0时，就意味着对象已经没有被任何人使用了，可以将其所占用的内存释放了。

优点：

简单、直观
实时性，只要没有了引用就释放资源。
缺点：

维护引用计数需要消耗一定的资源
循环应用时，无法回收。也正是因为这个原因，才需要通过标记-清理和分代收集机制来辅助引用计数机制。

2）、标记-清除
“标记-清除”不改动真实的引用计数，而是将
集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副
本做任何的改动，都不会影响到对象生命走起的维护。

3）、分代回收
将系统中的所有内存块根据其存活时间划分为不同的集合，
每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。
也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。
那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，
如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。
```