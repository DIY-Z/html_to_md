# 41.django 中如何实现 websocket?
django实现websocket大致上有两种方式，一种channels，一种是dwebsocket。channels依赖于redis，twisted等，相比之下使用dwebsocket要更为方便一些。
```python
安装
# pip install dwebsocket

配置：

# setting.py
 
INSTALLED_APPS = [
    .....
    .....
    'dwebsocket',
]
 
MIDDLEWARE_CLASSES = [
    ......
    ......
    'dwebsocket.middleware.WebSocketMiddleware'  # 为所有的URL提供websocket，如果只是单独的视图需要可以不选
 
]
WEBSOCKET_ACCEPT_ALL=True   # 可以允许每一个单独的视图实用websockets


简单使用：
模拟文件下载的简单示例

from dwebsocket.decorators import accept_websocket
@accept_websocket
def test(request):
    if not request.is_websocket():  # 判断是不是websocket连接
        return render(request, 'websocket.html')
    else:
        download = Haproxy()
        t = threading.Thread(target=download.run)
        t.start()
        sent = []
        while download.status:
            if len(download.res_dict) > len(sent):
                for i in download.res_dict.keys():
                    if i not in sent:
                        sent.append(i)
                request.websocket.send(str(sent[-1]+str(download.res_dict[sent[-1]])).encode('utf-8'))  # 发送消息到客户端
        if not download.status:
            request.websocket.send('下载完成'.encode('utf-8'))
```
dwebsocket有两种装饰器：require_websocket和accept_websocekt，使用require_websocket装饰器会导致视图函数无法接收导致正常的http请求，一般情况使用accept_websocket方式就可以了，
dwebsocket的一些内置方法：
request.is_websocket（）：判断请求是否是websocket方式，是返回true，否则返回false<br />
request.websocket： 当请求为websocket的时候，会在request中增加一个websocket属性，<br />
WebSocket.wait（） 返回客户端发送的一条消息，没有收到消息则会导致阻塞<br />
WebSocket.read（） 和wait一样可以接受返回的消息，只是这种是非阻塞的，没有消息返回None<br />
WebSocket.count_messages（）返回消息的数量<br />
WebSocket.has_messages（）返回是否有新的消息过来<br />
WebSocket.send（message）像客户端发送消息，message为byte类型
# 42.Python web 开发中, 跨域问题的解决思路是?
```python
# 方案1.安装django-cors-headers
pip install django-cors-header

配置settings.py文件
 
INSTALLED_APPS = [
    ...
    'corsheaders'，
    ...
 ] 
MIDDLEWARE_CLASSES = (
    ...
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware', # 注意顺序
    ...
)
#跨域增加忽略
CORS_ALLOW_CREDENTIALS = True
CORS_ORIGIN_ALLOW_ALL = True
CORS_ORIGIN_WHITELIST = (
    '*'
)
CORS_ALLOW_METHODS = (
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
    'VIEW',
)
CORS_ALLOW_HEADERS = (
    'XMLHttpRequest',
    'X_FILENAME',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
    'Pragma',
)

# 方案2.使用JSONP
使用Ajax获取json数据时，存在跨域的限制。不过，在Web页面上调用js的script脚本文件时却不受跨域的影响，JSONP就是利用这个来实现跨域的传输。因此，我们需要将Ajax调用中的dataType从JSON改为JSONP（相应的API也需要支持JSONP）格式。
JSONP只能用于GET请求。

# 方案3.直接修改Django中的views.py文件

修改views.py中对应API的实现函数，允许其他域通过Ajax请求数据：
def myview(_request):
  response = HttpResponse(json.dumps({“key”: “value”, “key2”: “value”}))
  response[“Access-Control-Allow-Origin”] = “*”
  response[“Access-Control-Allow-Methods”] = “POST, GET, OPTIONS”
  response[“Access-Control-Max-Age”] = “1000”
  response[“Access-Control-Allow-Headers”] = “*”
  return response
```
# 43.什么是wsgi?
```python
WSGI的全称是Web Server Gateway Interface，翻译过来就是Web服务器网关接口。具体的来说，WSGI是一个规范，定义了Web服务器如何与Python应用程序进行交互，使得使用Python写的Web应用程序可以和Web服务器对接起来。

```
# 44.列举django的内置组件?
```python
.Admin是对model中对应的数据表进行增删改查提供的组件
.model组件：负责操作数据库
.form组件：1.生成HTML代码2.数据有效性校验3校验信息返回并展示
.ModelForm组件即用于数据库操作,也可用于用户请求的验证  
```
# 45.django 中 model 的 SlugField 类型字段有什么用途
SlugField 本质上相当于存放字符串，但是在意义上，主要用于把某些字段形成语义化的，可以访问的短网址（slug）字符串。