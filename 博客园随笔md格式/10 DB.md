<img src="https://img-blog.csdnimg.cn/2018110811492258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbWluaWNKaQ==,size_16,color_FFFFFF,t_70" />
### 一．Mysql
1、from子句组装来自不同数据源的数据；<br />
2、where子句基于指定的条件对记录行进行筛选；<br />
3、group by子句将数据划分为多个分组；<br />
4、使用聚集函数进行计算；<br />
5、使用having子句筛选分组；<br />
6、计算所有的表达式；<br />
7、select 的字段；<br />
8、使用order by对结果集进行排序。<br />
SQL语言不同于其他编程语言的最明显特征是处理代码的顺序。在大多数据库语言中，代码按<br />
编码顺序被处理。但在SQL语句中，第一个被处理的子句式 FROM，而不是第一出现的SELECT。<br />
SQL查询处理的步骤序号：
(1) FROM <left_table>
(2) <join_type> JOIN <right_table>
(3) ON <join_condition>
(4) WHERE <where_condition>
(5) GROUP BY <group_by_list>
(6) WITH {CUBE | ROLLUP}
(7) HAVING <having_condition>
(8) SELECT
(9) DISTINCT
(9) ORDER BY <order_by_list>
(10) <TOP_specification> <select_list><br />
以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用<br />
者(客户端应用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。如果没有在<br />
查询中指定某一个子句，将跳过相应的步骤。<br />
逻辑查询处理阶段简介：<br />
1、 FROM：对FROM子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表VT1。<br />
2、 ON：对VT1应用ON筛选器，只有那些使为真才被插入到TV2。<br />
3、 OUTER (JOIN):如果指定了OUTER JOIN(相对于CROSS JOIN或INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到VT2，生成TV3。如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表位置。<br />
4、 WHERE：对TV3应用WHERE筛选器，只有使为true的行才插入TV4。<br />
5、 GROUP BY：按GROUP BY子句中的列列表对TV4中的行进行分组，生成TV5。<br />
6、 CUTE|ROLLUP：把超组插入VT5，生成VT6。<br />
7、 HAVING：对VT6应用HAVING筛选器，只有使为true的组插入到VT7。<br />
8、 SELECT：处理SELECT列表，产生VT8。<br />
9、 DISTINCT：将重复的行从VT8中删除，产品VT9。<br />
10、 ORDER BY：将 VT9中的行按ORDER BY子句中的列列表顺序，生成一个游标(VC10)。<br />
11、 TOP：从 VC10的开始处选择指定数量或比例的行，生成表TV11，并返回给调用者。 where子句中的条件书写顺序
##### 1. 常见SQL（必备）
详见武沛齐博客：<a href="https://www.cnblogs.com/wupeiqi/articles/5729934.html" class="uri">https://www.cnblogs.com/wupeiqi/articles/5729934.html</a>
##### 2. 什么是事务，MySQL是如何支持事务的？
事务就是一段sql 语句的批处理，但是这个批处理是一个原子 ，不可分割，要么都执行，要么回滚（rollback）都不执行。<br />
事务具体四大特性，也就是经常说的ACID ：<br />
1.原子性（所有操作要么全部成功，要么全部失败回滚）<br />
2.一致性（事务执行之前和执行之后都必须处于一致性状态。）<br />
3.隔离性（数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离）<br />
4.持久性（一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，<br />
即使遭遇故障依然能够通过日志恢复最后一次更新在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务<br />
MYSQL 事务处理主要有两种方法：<br />
1、用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认<br />
2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交
##### 3. 说一下Mysql数据库存储的原理？
储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有 用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。<br />
存储过程通常有以下优点：<br />
1、存储过程能实现较快的执行速度<br />
2、存储过程允许标准组件是编程。<br />
3、存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。<br />
4、存储过程可被作为一种安全机制来充分利用。<br />
5、存储过程能够减少网络流量
##### 4. 数据库索引种类？
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度<br />
**MySQL索引的类型：**
<ol>
- 普通索引：这是最基本的索引，它没有任何限制<br />
2.唯一索引：索引列的值必须唯一，但允许有空值，如果是组合索引，则列值的组合必须唯一<br />
　　 3.全文索引：全文索引仅可用于 MyISAM 表，可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加（切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法）
- 单列索引、多列索引：多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。<br />
5.组合索引（最左前缀）：简单的理解就是只从最左面的开始组合（实在单列索引的基础上进一步压榨索引效率的一种方式）
</ol>
##### 5. 索引在什么情况下遵循最左前缀的规则？
mysql在使用组合索引查询的时候需要遵循“最左前缀”规则
##### 6. MySQL常见的函数？　
聚合函数：<br />
　　 AVG(col)返回指定列的平均值<br />
　　 COUNT(col)返回指定列中非NULL值的个数<br />
　　 MIN(col)返回指定列的最小值<br />
　　 MAX(col)返回指定列的最大值<br />
　　 SUM(col)返回指定列的所有值之和<br />
　　 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果<br />
数学函数：<br />
　　 ABS(x) 返回x的绝对值<br />
　　 BIN(x) 返回x的二进制（OCT返回八进制，HEX返回十六进制）
##### 7. 如何开启慢日志查询？
1 执行 SHOW VARIABLES LIKE “%slow%”，获知 mysql 是否开启慢查询 slow_query_log 慢查询开启状态 OFF 未开启 ON 为开启 slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）<br />
2 修改配置文件（ 放在[mysqld]下），重启 long_query_time 查询超过多少秒才记录<br />
3 测试是否成功<br />
4 慢查询日志文件的信息格式
##### 8. 数据库导入导出命令（结构+数据）？
**1.导出整个数据库** 　<br />
　mysqldump -u用户名 -p密码 数据库名 > 导出的文件名 　　<br />
例如：C:\Users\jack> mysqldump -uroot -pmysql sva_rec > e:\sva_rec.sql 　<br />
**2.导出一个表，包括表结构和数据** 　<br />
　mysqldump -u用户名 -p 密码 数据库名 表名> 导出的文件名 　　<br />
例如：C:\Users\jack> mysqldump -uroot -pmysql sva_rec date_rec_drv> e:\date_rec_drv.sql 　<br />
**3.导出一个数据库结构** 　<br />
　例如：C:\Users\jack> mysqldump -uroot -pmysql -d sva_rec > e:\sva_rec.sql<br />
**4.导出一个表，只有表结构** 　<br />
　mysqldump -u用户名 -p 密码 -d数据库名 表名> 导出的文件名 　　<br />
例如：C:\Users\jack> mysqldump -uroot -pmysql -d sva_rec date_rec_drv> e:\date_rec_drv.sql 　　<br />
**5.导入数据库** 　　<br />
常用source 命令 　　<br />
进入mysql数据库控制台， 　　<br />
如mysql -u root -p 　　mysql>use 数据库 　　<br />
然后使用source命令，后面参数为脚本文件(如这里用到的.sql) 　　<br />
mysql>source d:wcnc_db.sql
##### 9. 数据库怎么优化查询效率？
1、储存引擎选择：如果数据表需要事务处理，应该考虑使用InnoDB，因为它完全符合ACID特性。<br />
如果不需要事务处理，使用默认存储引擎MyISAM是比较明智的<br />
2、分表分库，主从。<br />
3、对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引<br />
4、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描<br />
5、应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描<br />
6、应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描<br />
7、Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志<br />
8、对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。
##### 10. Mysql集群的优缺点？
优点：

- 99.999%的高可用性
- 快速的自动失效切换
- 灵活的分布式体系结构，没有单点故障
- 高吞吐量和低延迟
- 可扩展性强，支持在线扩容<br />
缺点：
- 存在很多限制，比如：不支持外键
- 部署、管理、配置很复杂
- 占用磁盘空间大、内存大
- 备份和恢复不方便
- 重启的时候，数据节点将数据load到内存需要很长的时间

##### 11. 你用的Mysql是哪个引擎，各引擎之间有什么区别？
主要 MyISAM 与 InnoDB 两个引擎，其主要区别如下：<br />
InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM就不可以了；<br />
MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；<br />
InnoDB 支持外键，MyISAM 不支持；<br />
MyISAM 是默认引擎，InnoDB 需要指定；<br />
InnoDB 不支持 FULLTEXT 类型的索引；<br />
InnoDB 中不保存表的行数，如 select count() from table 时，InnoDB；需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count()语句包含 where 条件时 MyISAM 也需要扫描整个表；<br />
对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM表中可以和其他字段一起建立联合索引；清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；<br />
InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'
##### 12. 数据库的优化？
1.优化索引、SQL 语句、分析慢查询；<br />
2.设计表的时候严格根据数据库的设计范式来设计数据库；<br />
3.使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘IO<br />
4.优化硬件；采用SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等<br />
5.采用MySQL 内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率；<br />
6.垂直分表；把一些不经常读的数据放在一张表里，节约磁盘I/O；<br />
7.主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来；<br />
8.分库分表分机器（数据量特别大），主要的的原理就是数据路由；<br />
9.选择合适的表引擎，参数上的优化<br />
10.进行架构级别的缓存，静态化和分布式；<br />
11.不采用全文索引；<br />
12.采用更快的存储方式，例如 NoSQL存储经常访问的数据**。
##### 13. Mysql数据库如何分区、分表？
分表可以通过三种方式：Mysql集群、自定义规则和merge存储引擎。<br />
分区有四类：<br />
RANGE 分区：基于属于一个给定连续区间的列值，把多行分配给分区。<br />
LIST 分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个<br />
值来进行选择。<br />
HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的<br />
这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br />
KEY 分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器<br />
提供其自身的哈希函数。必须有一列或多列包含整数值。
##### 14. Sql注入是如何产生的，如何防止？
程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量<br />
POST和GET提交一些sql语句正常执行。产生Sql注入。下面是防止办法：
a. 过滤掉一些常见的数据库操作关键字，或者通过系统函数来进行过滤。
b. 在PHP配置文件中将Register_globals=off;设置为关闭状态
c. SQL语句书写的时候尽量不要省略小引号(tab键上面那个)和单引号
d. 提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的
e. 对于常用的方法加以封装，避免直接暴漏SQL语句
f. 开启PHP安全模式：Safe_mode=on;
g. 打开magic_quotes_gpc来防止SQL注入
h. 控制错误信息：关闭错误提示信息，将错误信息写到系统日志。
i. 使用mysqli或pdo预处理。
##### 15. NoSQL和关系数据库的区别？
a. SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。
b. 在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。
c. SQL中如果需要增加外部关联数据的话，规范化做法是在原表中增加一个外键，关联外部数据表。而在NoSQL中除了这种规范化的外部数据表做法以外，我们还能用如下的非规范化方式把外部数据直<br />
接放到原数据集中，以提高查询效率。缺点也比较明显，更新审核人数据的时候将会比较麻烦。
d. SQL 中可以使用JOIN表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。NoSQL暂未提供类似JOIN的查询方式对多个数据集中的数据做查询。所以大部分NoSQL使用非规范化的数据存储方式存储数据。
e. SQL中不允许删除已经被使用的外部数据，而NoSQL中则没有这种强耦合的概念，可以随时删除任何数据。
f. SQL中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成功。这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。而NoSQL中没有事务这个概念，每一个数据集的操作都是原子级的。
g. 在相同水平的系统设计的前提下，因为NoSQL中省略了JOIN查询的消耗，故理论上性能上是优于SQL的。
##### 16. 简述触发器、函数、视图、存储过程？
触发器：触发器是一个特殊的存储过程，它是MySQL在insert、update、delete的时候自动执行的代码块。
```python
create trigger trigger_name
　　 after/before insert /update/delete on 表名
　　 for each row
　　 begin
　　 sql语句：（触发的语句一句或多句）
　　 end
```
函数：MySQL中提供了许多内置函数，还可以自定义函数（实现程序员需要sql逻辑处理）
```python
自定义函数创建语法：
　　 创建：CREATE FUNCTION 函数名称(参数列表) 　
　　　       RETURNS 返回值类型 　函数体
 　　修改：ALTER FUNCTION 函数名称 [characteristic ...]
　　 删除：DROP FUNCTION [IF EXISTS] 函数名称
　　 调用：SELECT 函数名称(参数列表)
```
视图：视图是由查询结果形成的一张虚拟表，是表通过某种运算得到的一个投影
```python
create view view_name as select 语句
```
存储过程：把一段代码封装起来，当要执行这一段代码的时候，<br />
可以通过调用该存储过程来实现（经过第一次编译后再次调用不需要再次编译，比一个个执行sql语句效率高）
```python
 create procedure 存储过程名(参数,参数,…)
　　 begin
　　 //代码
　　 end
```
##### 17. 列举 创建索引但是无法命中索引的8种情况。

- 1、如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因）
- 2、对于多列索引，不是使用的第一部分(第一个)，则不会使用索引
- 3、like查询是以%开头
- 4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
- 5、如果mysql估计使用全表扫描要比使用索引快,则不使用索引
- 6 对小表查询
- 7 提示不使用索引
- 8 统计数据不真实
- 9.单独引用复合索引里非第一位置的索引列.

##### 18. 优化数据库？提高数据库的性能
<ol>
- 对语句的优化<br />
①用程序中，保证在实现功能的基础上，尽量减少对数据库的访问次数；<br />
通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；<br />
②能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；<br />
③在查询时，不要过多地使用通配符如 SELECT * FROM T1 语句，要用到几列就选择几列如：<br />
SELECT COL1,COL2 FROM T1；<br />
④在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。<br />
⑤不要在应用中使用数据库游标，游标是非常有用的工具，但比使用常规的、面向集的SQL语句需要更大的开销；按照特定顺序提取数据的查找。
- 避免使用不兼容的数据类型<br />
例如float和int、char和varchar、binary 和varbinary是不兼容的。<br />
数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。<br />
例如:<br />
SELECT name FROM employee WHERE salary ＞ 60000<br />
在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000 是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。 若在查询时强制转换，查询速度会明显减慢。
- 避免在WHERE子句中对字段进行函数或表达式操作。<br />
若进行函数或表达式操作，将导致引擎放弃使用索引而进行全表扫描。
- 避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符<br />

- 尽量使用数字型字段<br />

- 合理使用EXISTS,NOT EXISTS子句。
- 尽量避免在索引过的字符数据中，使用非打头字母搜索。
- 分利用连接条件
- 消除对大型表行数据的顺序存取<br />

- 避免困难的正规表达式<br />

- 使用视图加速查询
- 能够用BETWEEN的就不要用IN
- DISTINCT的就不用GROUP BY
- 部分利用索引
- 能用UNION ALL就不要用UNION
- 不要写一些不做任何事的查询
- 尽量不要用SELECT INTO语句
- 必要时强制查询优化器使用某个索引
- 虽然UPDATE、DELETE语句的写法基本固定，但是还是对UPDATE语句给点建议：
a) 尽量不要修改主键字段。
b) 当修改VARCHAR型字段时，尽量使用相同长度内容的值代替。
c) 尽量最小化对于含有UPDATE触发器的表的UPDATE操作。
d) 避免UPDATE将要复制到其他数据库的列。
e) 避免UPDATE建有很多索引的列。
f) 避免UPDATE在WHERE子句条件中的列。
</ol>
##### 19. 数据库负载均衡
负载均衡集群是由一组相互独立的计算机系统构成，通过常规网络或专用网络进行连接，由路由器衔接在一起，各节点相互协作、共同负载、均衡压力，对客户端来说，整个群集可以视为一台具有超高性能的独立服务器。<br />
**1、 实现原理**<br />
实现数据库的负载均衡技术，首先要有一个可以控制连接数据库的控制端。在这里，它截断了数据库和程序的直接连接，由所有的程序来访问这个中间层，然后再由中间层来访问数据库。这样，我们就可以具体控制访问某个数据库了，然后还可以根据数据库的当前负载采取有效的均衡策略，来调整每次连接到哪个数据库。<br />
**2、 实现多据库数据同步**<br />
对于负载均衡，最重要的就是所有服务器的数据都是实时同步的。这是一个集群所必需的，因为，如果数不据实时、不同步，那么用户从一台服务器读出的数据，就有别于从另一台服务器读出的数据，这是不能允许的。所以必须实现数据库的数据同步。这样，在查询的时候就可以有多个资源，实现均衡。比较常用的方法是Moebius for SQL Server集群，Moebius for SQL Server集群<br />
采用将核心程序驻留在每个机器的数据库中的办法，这个核心程序称为Moebius for SQL Server 中间件，主要作用是监测数据库内数据的变化并将变化的数据同步到其他数据库中。数据同步完成后客户端才会得到响应，同步过程是并发完成的，所以同步到多个数据库和同步到一个数据库的时间基本相等；另外同步的过程是在事务的环境下完成的，保证了多份数据在任何时刻数据的一致性。正因为Moebius 中间件宿主在数据库中的创新，让中间件不但能知道数据的变化，而且知道引起数据变化的SQL语句，根据SQL语句的类型智能的采取不同的数据同步的策略以保证数据同步成本的最小化。<br />
数据条数很少，数据内容也不大，则直接同步数据。数据条数很少，但是里面包含大数据类型，比如文本，二进制数据等，则先对数据进行压缩然后再同步，从而减少网络带宽的占用和传输所用的时间。 数据条数很多，此时中间件会拿到造成数据变化的SQL语句， 然后对SQL语句进行解析，分析其执行计划和执行成本，并选择是同步数据还是同步SQL语句到其他的数据库中。此种情况应用在对表结构进行调整或者批量更改数据的时候非常有用。<br />
**3、 优缺点**<br />
优点：<br />
1) 扩展性强：当系统要更高数据库处理速度时，只要简单地增加数据库服务器就 可以得到扩展。<br />
2) 可维护性：当某节点发生故障时，系统会自动检测故障并转移故障节点的应用，保证数据库的持续工作。<br />
3) 安全性：因为数据会同步的多台服务器上，可以实现数据集的冗余，通过多份数据来保证安全性。另外它成功地将数据库放到了内网之中，更好地保护了数据库的安全性。<br />
4) 易用性：对应用来说完全透明，集群暴露出来的就是一个IP<br />
缺点：
a) 不能够按照Web服务器的处理能力分配负载。
b) 负载均衡器(控制端)故障，会导致整个数据库系统瘫痪。
##### 20. 数据库三大范式？
**什么是范式：**简言之就是，数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些 规范的来优化数据数据存储方式。在关系型数据库中这些规范就可以称为范式。<br />
**什么是三大范式：**<br />
第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。<br />
第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。<br />
第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.<br />
注：关系实质上是一张二维表，其中每一行是一个元组，每一列是一个属性
##### 21. 简述数据库设计中一对多和多对多的应用场景？　　
一对多：学生与班级---一个学生只能属于一个班级，一个班级可以有多个学生<br />
多对多：学生与课程---一个学生可以选择多个课程，一个课程也可以被多个学生选择
##### 22. 如何基于数据库实现商城商品计数器？
创建一个商城表---包含（id，商品名，每一个商品对应数量）
```python
create table product
　　(id primary key auto_increment,
　　　 pname varchar(64),
　　　　 pcount int);
```
##### 23. char和varchar的区别？
**char：**定长，char的存取数度相对快<br />
**varchar：**不定长，存取速度相对慢<br />
到底如何取舍可以根据一下几个方面考虑：<br />
1、对于MyISAM表，尽量使用Char，对于那些经常需要修改而容易形成碎片的myisam和isam数据表就更是如此，它的缺点就是占用磁盘空间；<br />
2、对于InnoDB表，因为它的数据行内部存储格式对固定长度的数据行和可变长度的数据行不加区分（所有数据行共用一个表头部分，这个标头部分存放着指向各有关数据列的指针），所以使用char类型不见得会比使用varchar类型好。事实上，因为char类型通常要比varchar类型占用更多的空间，所以从减少空间占用量和减少磁盘i/o的角度，使用varchar类型反而更有利；<br />
3、存储很短的信息，比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的现在得不偿失。<br />
4、固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。<br />
5、十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。
##### 24. 在对name做了唯一索引前提下，简述以下区别：
```python
select * from tb where name = ‘Oldboy’ -------------查找到tb表中所有name = ‘Oldboy’的数据

select * from tb where name = ‘Oldboy’ limit 1------查找到tb表中所有name = ‘Oldboy’的数据只取其中的第一条
```
##### 25.MySQL 常见数据库引擎及区别?
```python
MySQL数据库引擎取决于MySQL在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下，MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。如果技术高超，还可以使用MySQL+API自己做一个引擎。下面介绍几种数据库引擎：

    ISAM：ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到 数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不 支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，那就必须经常备份你所有的实 时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。
    MyISAM：MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMCHK工具和用来恢复浪费空间的 MyISAMPACK工具。MYISAM强调了快速读取操作，这可能就是为什么MySQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据。
    HEAP：HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP也不会浪费大量的空间。HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。
    InnoDB：InnoDB数据库引擎都是造就MySQL灵活性的技术的直接产品，这项技术就是MYSQL+API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MyISAM数据库引擎不支持事务处理（transaction process）也不支持外来键。尽管要比ISAM和 MyISAM引擎慢很多，但是InnoDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者 或者两者，那你就要被迫使用后两个引擎中的一个了。
    如果感觉自己的确技术高超，你还能够使用MySQL+API来创建自己的数据库引擎。这个API为你提供了操作字段、记录、表格、数据库、连接、安全帐号的功能，以及建立诸如MySQL这样DBMS所需要的所有其他无数功能。深入讲解API已经超出了本文的范围，但是你需要了解MySQL+API的存在及其可交换引擎背后的技术，这一点是很重要的。估计这个插件式数据库引擎的模型甚至能够被用来为MySQL创建本地的XML提供器（XML provider）。（任何读到本文的MySQL+API开发人员可以把这一点当作是个要求。）
MyISAM与InnoDB的区别
　　InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。
```
##### 26.简述事务及其特性?
```python
事务具有四个特性，即 ACID 特性：
（ 1 ）原子性：事务中包括的所有操作要么都做，要么都不做。
（ 2 ）一致性：事务必须使数据库从一个一致性状态变到另一个一致性状态。
（ 3 ）隔离性：一个事务内部的操作及使用的数据对并发的其他事务是隔离的。
（ 4 ）持续性：事务一旦提交，对数据库的改变是永久的。
```
##### 27.简述触发器、函数、视图、存储过程?
```python
触发器：触发器是一个特殊的存储过程，它是MySQL在insert、update、delete的时候自动执行的代码块。

函数：MySQL中提供了许多内置函数，还可以自定义函数（实现程序员需要sql逻辑处理）
　　 自定义函数创建语法：
　　　　   创建：CREATE FUNCTION 函数名称(参数列表) 　
　　　       RETURNS 返回值类型 　函数体
 　　修改： ALTER FUNCTION 函数名称 [characteristic ...]
　　 删除：DROP FUNCTION [IF EXISTS] 函数名称
　　 调用：SELECT 函数名称(参数列表)
  
视图：视图是由查询结果形成的一张虚拟表，是表通过某种运算得到的一个投影
　　 　　 create view view_name as select 语句
  
存储过程：把一段代码封装起来，当要执行这一段代码的时候，可以通过调用该存储过程来实现（经过第一次编译后再次调用不需要再次编译，比一个个执行sql语句效率高）
　　 create procedure 存储过程名(参数,参数,…)
　　 begin
　　 //代码
　　 end
```
##### 28.简述MySQL的执行计划的作用及使用方法?
```sql
作为程序员，难免要和数据库打交道，一般情况下，我们不是DBA ，但是又要写很多SQL，因此SQL效率就成了很大的问题。关于SQL效率优化，除了要掌握一定优化技巧外， 还得有很多经验的积累，但是这里我们可以通过执行计划对SQL进行分析，能快速找到优化的地方，这是一种很不错的方式

1.查看mysql执行计划
explain  select ......
2.执行计划包含的信息
Column Meaning
id  The SELECT identifier
select_type The SELECT type
table   The table for the output row
partitions  The matching partitions
type    The join type
possible_keys   The possible indexes to choose
key The index actually chosen
key_len The length of the chosen key
ref The columns compared to the index
rows    Estimate of rows to be examined
filtered    Percentage of rows filtered by table condition
Extra   Additional information

(1).id
含义，指示select字句或操作表的顺序。
(2).select_type
含义：select语句的类型
(3).type
含义：获取记录行采用的方式，亦即mysql的访问方式。
(4).possible_keys
含义：指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
(5).key
含义：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL
(6)key_len
含义：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
(7)ref
含义：用于连接查询，表示具体某个表的某列被引用
(8)rows
含义：MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数,这个值是不准确的，只有参考意义。
 (9)Extra
含义：显示一些辅助的额外信息
```
##### 29.1000w 条数据，使用 limit offset 分页时，为什么越往后翻越慢?如何解决?
```sql
当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。

如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。

如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。
```
##### 30.什么是索引合并?
```python
The Index Merge method is used to retrieve rows with several range scans and to merge their results into one. The merge can produce unions, intersections, or unions-of-intersections of its underlying scans. This access method merges index scans from a single table; it does not merge scans across multiple tables.

根据官方文档中的说明，我们可以了解到：
1、索引合并是把几个索引的范围扫描合并成一个索引。
2、索引合并的时候，会对索引进行并集，交集或者先交集再并集操作，以便合并成一个索引。
3、这些需要合并的索引只能是一个表的。不能对多表进行索引合并。
```
##### 31.什么是覆盖索引?
```sql
如果一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’。即只需扫描索引而无须回表。
只扫描索引而无需回表的优点：
    1.索引条目通常远小于数据行大小，只需要读取索引，则mysql会极大地减少数据访问量。
    2.因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很多。
    3.一些存储引擎如myisam在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用
    4.innodb的聚簇索引，覆盖索引对innodb表特别有用。(innodb的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询)

覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B-tree索引做覆盖索引。

当发起一个索引覆盖查询时，在explain的extra列可以看到using index的信息
```
##### 32.简述数据库读写分离?
```sql
MySQL Proxy最强大的一项功能是实现“读写分离(Read/Write Splitting)”。基本的原理是让主数据库处理事务性查询，而从数据库处理SELECT查询。数据库复制被用来把事务性查询导致的变更同步到集群中的从数据库。 当然，主服务器也可以提供查询服务。使用读写分离最大的作用无非是环境服务器压力。

读写分离的好处
1、增加冗余
2、增加了机器的处理能力
3、对于读操作为主的应用，使用读写分离是最好的场景，因为可以确保写的服务器压力更小，而读又可以接受点时间上的延迟。

读写分离提高性能之原因
1、物理服务器增加，负荷增加
2、主从只负责各自的写和读，极大程度的缓解X锁和S锁争用
3、从库可配置myisam引擎，提升查询性能以及节约系统开销
4、从库同步主库的数据和主库直接写还是有区别的，通过主库发送来的binlog恢复数据，但是，最重要区别在于主库向从库发送binlog是异步的，从库恢复数据也是异步的
5、读写分离适用与读远大于写的场景，如果只有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能不高。 对于写和读比例相近的应用，应该部署双主相互复制
6、可以在从库启动是增加一些参数来提高其读的性能，例如--skip-innodb、--skip-bdb、--low-priority-updates以及--delay-key-write=ALL。当然这些设置也是需要根据具体业务需求来定得，不一定能用上
7、分摊读取。假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白了就是拿机器和带宽换性能。MySQL官方文档中有相关演算公式：官方文档 见6.9FAQ之“MySQL复制能够何时和多大程度提高系统性能”
8、MySQL复制另外一大功能是增加冗余，提高可用性，当一台数据库服务器宕机后能通过调整另外一台从库来以最快的速度恢复服务，因此不能光看性能，也就是说1主1从也是可以的。
```
##### 33.简述数据库分库分表?(水平、垂直)
```python
# 水平分库
1、概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
2、结果：
  每个库的结构都一样；
  每个库的数据都不一样，没有交集；
  所有库的并集是全量数据；
3、场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
4、分析：库多了，io和cpu的压力自然可以成倍缓解。

# 水平分表
1、概念：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
2、结果：
  每个表的结构都一样；
  每个表的数据都不一样，没有交集；
  所有表的并集是全量数据；
3、场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。
4、分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。

# 垂直分库
1、概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
2、结果：
  每个库的结构都不一样；
  每个库的数据也不一样，没有交集；
  所有库的并集是全量数据；
3、场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。
4、分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。

# 垂直分表
1、概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。
2、结果：
  2.1、每个表的结构都不一样；
  2.2、每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；
  2.3、所有表的并集是全量数据；
3、场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。
4、分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。
但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。
```
##### 34.数据库锁的作用?
```sql
根据不同的锁的作用域我们可以把数据库的锁分为三种，分别为：
  行锁：对表中的某一行进行加锁。
  页锁：对表中一组连续的行进行加锁。
  表锁：对整张表进行加锁
不同的作用域对并发性能是有很大影响的，比如说如果数据库的插入都是使用表锁，那在大量用户对某张表进行插入读取操作的话，同时只能有一个用户可以访问该表，那并发量肯定就是惨不忍睹了。

乐观锁
在乐观锁中，我们有3种常用的做法来实现：

第一种就是在数据取得的时候把整个数据都copy到应用中，在进行提交的时候比对当前数据库中的数据和开始的时候更新前取得的数据。当发现两个数据一模一样以后，就表示没有冲突可以提交，否则则是并发冲突，需要去用业务逻辑进行解决。

第二种乐观锁的做法就是采用版本戳，这个在Hibernate中得到了使用。采用版本戳的话，首先需要在你有乐观锁的数据库table上建立一个新的column，比如为number型，当你数据每更新一次的时候，版本数就会往上增加1。比如同样有2个session同样对某条数据进行操作。两者都取到当前的数据的版本号为1，当第一个session进行数据更新后，在提交的时候查看到当前数据的版本还为1，和自己一开始取到的版本相同。就正式提交，然后把版本号增加1，这个时候当前数据的版本为2。当第二个session也更新了数据提交的时候，发现数据库中版本为2，和一开始这个session取到的版本号不一致，就知道别人更新过此条数据，这个时候再进行业务处理，比如整个Transaction都Rollback等等操作。在用版本戳的时候，可以在应用程序侧使用版本戳的验证，也可以在数据库侧采用Trigger(触发器)来进行验证。不过数据库的Trigger的性能开销还是比较的大，所以能在应用侧进行验证的话还是推荐不用Trigger。

第三种做法和第二种做法有点类似，就是也新增一个Table的Column，不过这次这个column是采用timestamp型，存储数据最后更新的时间。在Oracle9i以后可以采用新的数据类型，也就是timestamp with time zone类型来做时间戳。这种Timestamp的数据精度在Oracle的时间类型中是最高的，精确到微秒(还没与到纳秒的级别)，一般来说，加上数据库处理时间和人的思考动作时间，微秒级别是非常非常够了，其实只要精确到毫秒甚至秒都应该没有什么问题。和刚才的版本戳类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。如果不想把代码写在程序中或者由于别的原因无法把代码写在现有的程序中，也可以把这个时间戳乐观锁逻辑写在Trigger或者存储过程中

悲观锁（排他锁）
悲观锁也称之为互斥锁，可以写为X锁，指的是同时只能有一个事务可以对某个资源进行访问操作。如果有两个事务同时要操作某张表，我们称之为事务A和事务B，如果事务A获得了这张表的表锁，那事务B只能等待事务A释放了这个锁之后才能对该表进行操作。

数据库的insert，update操作默认是采用互斥锁进行加锁，读取select则不是，如果要对select操作使用互斥锁，可以这样写

select * from table where id = 1 for update
共享锁
共享锁是一种乐观锁，可以写为S锁，在数据库中共享锁的作用主要是针对读取操作的。如果读取操作使用X锁的话，并发量会非常低，所以数据库提供了共享锁S锁，提高读取操作的并发性能，多个事务可以同时持有一个资源的S锁，不像X锁，同时只能有一个事务持有。

举个例子：

事务A和事务B对表TABLE进行访问，事务A想查看id = 1的行信息

select * from TABLE where id = 1 lock in share mode
如果当前id = 1的行对应的X锁没有被其他事务获取，那事务A就顺利的获得了该行的S锁。

现在事务B也想查看id = 1 的行信息，会怎么样？

select * from TABLE where id = 1 lock in share mode
现在持有该行锁的只有事务A，持有的是S锁，所以事务B也可以获取该行的S锁，两个事务可以并发的读取id = 1的行。

这个和之前所说的乐观锁实现是有区别的，最大的不同就是读取的时候共享锁是要真的去持有锁，但是乐观锁只是实现了一种CAS模式，但是并读取的时候没有真的持有锁。
```
##### 35.where 子句中有 a,b,c 三个查询条件, 创建一个组合索引 abc(a,b,c)，以下哪 种会命中索引
```sql
(a)   *****
(b)
(c)
(a,b)    *****
(b,c)
(a,c)
(a,b,c)   *****

```
##### 36.mysql 下面那些查询不会使用索引,between, like "c%" , not in, not exists, !=, <, <=, =, >, >=,in
##### 37.mysql 中 varchar 与 char 的区别以及 varchar(50)中的 50 代表的含义
```sql
varchar与char的区别char是一种固定长度的类型，varchar则是一种可变长度的类型 
尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间， 
其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

varchar(50)代表的含义：
varchar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，
因为order by col采用fixed_length计算col长度(memory引擎也一样) 

```
##### 38.从delete语句中省略where子句,将产生什么后果?
```python
A. delete语句将失败因为没有记录可删除 
B. delete语句将从表中删除所有的记录    *****
C. delete语句将􏰀示用户进入删除的标准 
D. delete语句将失败,因为语法错误 

```
##### 39.叙述mysql半同步复制原理
```python
mysql的主备库通过binlog日志保持一致，主库本地执行完事务，binlog日志落盘后即返回给用户；备库通过拉取主库binlog日志来同步主库的操作。默认情况下，主库与备库并没有严格的同步，因此存在一定的概率备库与主库的数据是不对等的。半同步特性的出现，就是为了保证在任何时刻主备数据一致的问题。相对于异步复制，半同步复制要求执行的每一个事务，都要求至少有一个备库成功接收后，才返回给用户。实现原理也很简单，主库本地执行完毕后，等待备库的响应消息(包含最新备库接收到的binlog(file,pos))，接收到备库响应消息后，再返回给用户，这样一个事务才算真正完成。在主库实例上，有一个专门的线程(ack_receiver)接收备库的响应消息，并以通知机制告知主库备库已经接收的日志，可以继续执行。

```
##### 40.sql 查询
存在的表有<br />
\1. products(商品表) columns 为 id, name, price<br />
\2. orders(商城订单表) columns 为 id, reservation_id, product_id, quentity(购买数量)<br />
\3. reservations(酒店订单表) columns 为 id,user_id, price, created
需要查询的:
<ol>
- 各个商品的售卖情况, 需要字段 商品名 购买总量 商品收入
- 所有用户在2018-01-01至2018-02-01下单次数,下单金额,商城下单次 数, 商城下单金额
- 历月下单用户数: 下单一次用户数, 下单两次用户数, 下单三次及以上用户 数
</ol>
##### 41.考虑如下表结构,写出建表语句
ID(自增主键) NAME(非空) Balance(非空)
1 A 19.50
2 A 20.50
3 A 100.00
```sql
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test` (
  `ID` int(11) NOT NULL AUTO_INCREMENT,
  `NAME` varchar(255) NOT NULL,
  `Balance` varchar(255) NOT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

SET FOREIGN_KEY_CHECKS = 1;

```
##### 42.假设学生Students和教师Teachers关系模型如下所示
1.Student:(学号,姓名,性别,类别,身份证号)
2.Teacher:(教师号,姓名,性别,身份证号,工资)
其中,学生关系中的类别分别为"本科生"和"研究生两类", 性别分为"男"和"女" 两类.<br />
查询研究生教师平均工资(显示为平均工资), 最高工资与最低工资之间的差值
(显示为差值)的 SQL 语句
```sql
select (1) as 平均工资, (2) as 差值 from Students,Teacher where (3);

```
查询工资少于 10000 元的女研究生教师的身份证号和姓名的 SQL 语句(非嵌套查 询方式);
```sql
select 身份证号,姓名 from Students where (4) (5)

select 身份证号,姓名 from Teachers where (6)

```
##### 43.mysql 中怎么创建索引?
```sql
建表时创建
CREATE TABLE 表名(
字段名 数据类型 [完整性约束条件],
       ……，
[UNIQUE | FULLTEXT | SPATIAL] INDEX | KEY
[索引名](字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]
);
说明:
UNIQUE:可选。表示索引为唯一性索引。
FULLTEXT:可选。表示索引为全文索引。
SPATIAL:可选。表示索引为空间索引。
INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是    一样的。
索引名:可选。给创建的索引取一个新名称。
字段名1:指定索引对应的字段的名称，该字段必须是前面定义好的字段。
长度:可选。指索引的长度，必须是字符串类型才可以使用。
ASC:可选。表示升序排列。
DESC:可选。表示降序排列。
注:索引方法默认使用BTREE。

```
##### 44.请简述sql注入的攻击原理及如何在代码层面防止sql注入?
```sql
所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。[1] 比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击．

根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：
①不当的类型处理；
②不安全的数据库配置；
③不合理的查询集处理；
④不当的错误处理；
⑤转义字符处理不合适；
⑥多个提交处理不当。

预防措施：

1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和
双"-"进行转换等。
2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等

```
##### 45.使用Python实现将数据库的student表中􏰀取的数据写入db.txt?
```python
import pymysql


host = '127.0.0.1'
user = 'root'
passwd = '123456'
port = '3306'
db = 'test'

# 链接数据库
conn = pymysql.connect(host=host,
                       port=port,
                       user=user,
                       passwd=passwd,
                       db=db,
                       charset='utf8', )
cur = conn.cursor()
cur.execute("SELECT * FROM student;")
data = cur.fetchall()

with open('db.txt', 'w') as f:
    for i in data:
        f.write(str(i) + '\n')

```
##### 46.简述leftjoin和rightjoin的区别?
```sql
left join:外链接之左连接：优先显示左表全部记录
                    #以左表为准，即找出所有员工信息，当然包括没有部门的员工
                    #本质就是：在内连接的基础上增加左边有右边没有的结果
right join:外链接之右连接：优先显示右表全部记录
          #以右表为准，即找出所有部门信息，包括没有员工的部门
          #本质就是：在内连接的基础上增加右边有左边没有的结果

```
##### 47.索引有什么作用,有那些分类,有什么好处和坏处?
```sql
作用：
索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

分类：
1、唯一索引

唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。

2、主键索引

数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。

3、聚集索引

在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

4、索引列

可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。

优点：

1、大大加快数据的检索速度。
2、创建唯一性索引，保证数据库表中每一行数据的唯一性。
3、加速表和表之间的连接。
4、在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。

缺点：

1、索引需要占物理空间。
2、当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。

```
##### 48.写sql语句
​ TableA
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ID</th>
<th style="text-align: center;">NAME</th>
<th style="text-align: center;">KECHENG</th>
<th style="text-align: center;">FENSHU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">张三</td>
<td style="text-align: center;">语文</td>
<td style="text-align: center;">81</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">张三</td>
<td style="text-align: center;">数学</td>
<td style="text-align: center;">75</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">李四</td>
<td style="text-align: center;">语文</td>
<td style="text-align: center;">76</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">李四</td>
<td style="text-align: center;">数学</td>
<td style="text-align: center;">90</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">王五</td>
<td style="text-align: center;">语文</td>
<td style="text-align: center;">81</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">王五</td>
<td style="text-align: center;">数学</td>
<td style="text-align: center;">100</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">王五</td>
<td style="text-align: center;">英语</td>
<td style="text-align: center;">90</td>
</tr>
</tbody>
</table>
​ TableB
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ID</th>
<th style="text-align: center;">NAME</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">张三</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">李四</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">王五</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">赵六</td>
</tr>
</tbody>
</table>
查询:
1.查询出每门课程都大于80分的学生姓
```sql
SELECT
    `NAME` 
FROM
    TableA 
WHERE
    `NAME` NOT IN (
    SELECT
        `NAME` 
    FROM
        TableA 
    WHERE
        FENSHU < 80 
    GROUP BY
        `NAME` 
    ) 
GROUP BY
    `NAME`;

```
2.查询出语文成绩最大的学生姓名
```sql
SELECT
    TableA.`NAME` 
FROM
    TableA 
WHERE
    FENSHU = (
    SELECT
        `FENSHU` 
    FROM
        TableA 
    WHERE
        KECHENG = "语文" 
    GROUP BY
        FENSHU 
    ORDER BY
        FENSHU DESC 
        LIMIT 1 
    ) 

```
3.查询没有成绩的学生姓名
```sql
SELECT
    `NAME` 
FROM
    TableB 
WHERE
    NAME NOT IN ( SELECT `NAME` FROM TableA GROUP BY `NAME` )

```
##### 49.试列出至少三种目前流行的大型关系型数据库的名称
```python
  试列出至少三种目前流行的大型关系型数据库的名称
  其中您最熟悉的是
  什么时候开始使用
  
  “”“
  Oracle
  SQL Server
  MySQL
  ”“”

```
##### 50.什么是MySQL慢日志?
```sql
慢日志查询的主要功能就是，记录sql语句中超过设定的时间阈值的查询语句。例如，一条查询sql语句，我们设置的阈值为1s，当这条查询语句的执行时间超过了1s，则将被写入到慢查询配置的日志中.
慢查询主要是为了我们做sql语句的优化功能.

配置项说明：
    登陆mysql服务：
    > show variables like '%query%';
    关注三个配置项即可。
  1.slow_query_log
  该配置项是决定是否开启慢日志查询功能，配置的值有ON或者OFF.
  2.slow_query_log_file
  该配置项是慢日志查询的记录文件,需要手动创建.
  3.long_query_time
  该配置项是设置慢日志查询的时间阈值，当超过这个阈值时，慢日志才会被记录.配置的值有0(任何的sql语句都记录下来)，或者>0(具体的阈值).该配置项是以秒为单位的，并且可以设置为小数.
  4.log-queries-not-using-indexes
  该配置项是为了记录未使用到索引的sql语句.

```
##### 51.了解过Hbase、DB2、SQLServer、Access吗?
```python
关系型数据库:mysql,db2,sqlserver,hbase,access

```
### 二．MongoDB
##### 1. MongoDB
MongoDB是一个面向文档的数据库系统。使用C++编写，不支持SQL，但有自己功能强大的查询语法。<br />
MongoDB使用BSON作为数据存储和传输的格式。BSON是一种类似JSON的二进制序列化文档，支持嵌套对象和数组。<br />
MongoDB很像MySQL，document对应MySQL的row，collection对应MySQL的table<br />
应用场景：
a) 网站数据：mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。
b) 缓存：由于性能很高，mongo也适合作为信息基础设施的缓存层。在系统重启之后，由mongo搭建的持久化缓存可以避免下层的数据源过载。
c) 大尺寸、低价值的数据：使用传统的关系数据库存储一些数据时可能会比较贵，在此之前，很多程序员往往会选择传统的文件进行存储。
d) 高伸缩性的场景：mongo非常适合由数十或者数百台服务器组成的数据库。
e) 用于对象及JSON数据的存储：mongo的BSON数据格式非常适合文档格式化的存储及查询。
f) 重要数据：mysql，一般数据：mongodb，临时数据：memcache
g) 对于关系数据表而言，mongodb是提供了一个更快速的视图view；而对于PHP程序而言，mongodb可以作为一个持久化的数组来使用，并且这个持久化的数组还可以支持排序、条件、限制等功能。
h) 将mongodb代替mysql的部分功能，主要一个思考点就是：把mongodb当作mysql的一个view（视图），view是将表数据整合成业务数据的关键。比如说对原始数据进行报表，那么就要先把原始数据统计后生成view，在对view进行查询和报表。 不适合的场景：
a) 高度事物性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。
b) 传统的商业智能应用：针对特定问题的BI数据库会对产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。
c) 需要SQL的问题
d) 重要数据，关系数据<br />
优点:<br />
1）弱一致性（最终一致），更能保证用户的访问速度<br />
2）文档结构的存储方式，能够更便捷的获取数<br />
3）内置GridFS，高效存储二进制大对象 (比如照片和视频)<br />
4）支持复制集、主备、互为主备、自动分片等特性<br />
5）动态查询<br />
6）全索引支持,扩展到内部对象和内嵌数组<br />
缺点:<br />
1）不支持事务<br />
2）MongoDB占用空间过大,维护工具不够成熟
##### 2. MySQL与MongoDB本质之间最基本的差别是什么
差别在多方面，例如：数据的表示、查询、关系、事务、模式的设计和定义、速度和性能。<br />
MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。<br />
MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br />
MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br />
MongoDB是一个面向文档的数据库，目前由10gen开发并维护，它的功能丰富齐全，所以完全可以替代MySQL。<br />
与MySQL等关系型数据库相比，MongoDB的优点如下：<br />
①弱一致性，更能保证用户的访问速度。<br />
②文档结构的存储方式，能够更便捷的获取数据。<br />
③内置GridFS，支持大容量的存储。<br />
④内置Sharding。<br />
⑤第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)<br />
⑥性能优越：<br />
MongoDB本身它还算比较年轻的一个产品，所以它的问题，就是成熟度肯定没有传统MySQL那么成熟稳定。所以在使用的时候，<br />
第一，尽量使用稳定版，不要在线上使用开发版，这是一个大原则；<br />
另外一点，备份很重要，MongoDB如果出现一些异常情况，备份一定是要能跟上。<br />
除了通过传统的复制的方式来做备份，离线备份也还是要有，不管你是用什么方式，都要有一个完整的离线备份。往往最后出现了特殊情况，它能帮助到你；<br />
另外，MongoDB性能的一个关键点就是索引，索引是不是能有比较好的使用效率，索引是不是能够放在内存中，这样能够提升随机读写的性能。如果你的索引不能完全放在内存中，一旦出现随机读写比较高的时候，它就会频繁地进行磁盘交换，这个时候，MongoDB的性能就会急剧下降，会出现波动。 另外，<br />
MongoDB还有一个最大的缺点，就是它占用的空间很大，因为它属于典型空间换时间原则的类型。那么它的磁盘空间比普通数据库会浪费一些，而且到目前为止它还没有实现在线压缩功能，在MongoDB中频繁的进行数据增删改时，如果记录变了，例如数据大小发生了变化，这时候容易产生一些数据碎片，出现碎片引发的结果，一个是索引会出现性能问题，<br />
另外一个就是在一定的时间后，所占空间会莫明其妙地增大，所以要定期把数据库做修复，定期重新做索引，这样会提升MongoDB的稳定性和效率。在最新的版本里，它已经在实现在线压缩，估计应该在2.0版左右，应该能够实现在线压缩，可以在后台执行现在repair DataBase的一些操作。如果那样，就解决了目前困扰我们的大问题。
##### 3. 使用MongoDB的优点
```
1. 面向文件  
2. 高性能 
3. 高可用 
4. 易扩展 
5. 可分片 
6. 对数据存储友好 

```
### 三．Redis
##### 1. Redis五大数据类型及对应使用场所。
**Hash**<br />
1. Hash 类型可以看成是一个key/value都是 String的Map容器。 通常用来存储对象数据类型<br />
2. 常用命令：hget,hset,hgetall 等。<br />
**List**<br />
1. List 用于存储一个有序的字符串列表，常用的操作是向队列两 端添加元素或者获得列表的某一片段。可用来做微信朋友圈按时间顺序加载<br />
2. 常用命令：lpush,rpush,lpop,rpop,lrange 等<br />
**Set**<br />
1. Set 可以理解为一组无序的字符集合，Set 中相同的元素是不会重复出现的，相同的元素只保留一个。可用来做共同好友，共同关注等<br />
2. 常用命令：sadd,spop,smembers,sunion 等。<br />
**Sorted Set（有序集合）**<br />
1. 有序集合是在集合的基础上为每一个元素关联一个分数，Redis通过分数为集合中的成员进行排序。可用来做各类排行榜应用<br />
2. 常用命令：zadd,zrange,zrem,zcard等。
##### 2. 怎样解决数据库高并发的问题？
解决数据库高并发的常见方案：<br />
1） 缓存式的Web应用程序架构：<br />
在Web层和DB(数据库)层之间加一层cache层，主要目的：减少数据库读取负担，提高数据读取速度。cache存取的媒介是内存，可以考虑采用分布式的cache层，这样更容易破除内存容量的限制，同时增加了灵活性。<br />
2） 增加Redis缓存数据库：<br />
3） 增加数据库索引<br />
4） 页面静态化：<br />
效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。用户可以直接获取页面，不用像MVC结构走那么多流程，比较适用于页面信息大量被前台程序调用，但是更新频率很小的情况。<br />
5） 使用存储过程：<br />
处理一次请求需要多次访问数据库的操作，可以把操作整合到储存过程，这样只要一次数据库访问就可以了。<br />
6） MySQL主从读写分离：<br />
当数据库的写压力增加，cache层（如Memcached）只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负。使用主从复制技术（master-slave模式）来达到读写分离，以提高读写性能和读库的可扩展性。读写分离就是只在主服务器上写，只在从服务器上读，基本原理是让主数据库处理事务性查询，而从数据库处理select查询，数据库复制被用于把事务性查询（增删改）导致的改变更新同步到集群中的从数据库。<br />
MySQL读写分离提升系统性能：<br />
1、主从只负责各自的读和写，极大程度缓解X锁和S锁争用。<br />
2、slave可以配置MyISAM引擎，提升查询性能以及节约系统开销。<br />
3、master直接写是并发的，slave通过主库发送来的binlog恢复数据是异步的。<br />
4、slave可以单独设置一些参数来提升其读的性能。<br />
5、增加冗余，提高可用性。<br />
实现主从分离可以使用MySQL中间件如：Atlas<br />
7） 分表分库：<br />
在cache层的高速缓存，MySQL的主从复制，读写分离的基础上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。采用Master-Slave复制模式的MySQL架构，只能对数据库的读进行扩展，而对数据的写操作还是集中在Master上。这时需要对数据库的吞吐能力进一步地扩展，以满足高并发访问与海量数据存储的需求。 对于访问极为频繁且数据量巨大的单表来说，首先要做的是减少单表的记录条数，以便减少数据查询所需的时间，提高数据库的吞吐，这就是所谓的分表【水平拆分】。在分表之前，首先需要选择适当的分表策略（尽量避免分出来的多表关联查询），使得数据能够较为均衡地分布到多张表中，并且不影响正常的查询。 分表能够解决单表数据量过大带来的查询效率下降的问题，但是却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展Slave服务器都是没有意义的，对数据库进行拆分，从而提高数据库写入能力，即分库【垂<br />
直拆分】。<br />
8） 负载均衡集群：<br />
将大量的并发请求分担到多个处理节点。由于单个处理节点的故障不影响整个服务，负载均衡集群同时也实现了高可用性。 负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。
##### 3.redis中的sentinel(哨兵模式)的作用?
在哨兵模式下，如果主机宕机了，会在从机里面投票选出一个从机当主机，之后如果原来的主机又回来了，在较短的时间内还没有被哨兵模式监控到的时候，回来的主机就是自己一个人单独一套体系自己是光杆司令，但是一会儿功夫，哨兵模式监控到了这个重启的主机后，哨兵模式会告诉这个新来的主机，已经换老大了，你需要跟着新老大混，这个时候新来的就会自动变为从机依附于前面投票选出来的主机
##### 4. Redis的并发竞争问题怎么解决？
方案一：可以使用独占锁的方式，类似操作系统的mutex机制，不过实现相对复杂，成本较高。<br />
方案二：使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）<br />
如何用乐观锁方式进行解决？ 本质上是假设不会进行冲突，使用redis的命令watch进行构造条件
##### 6. Redis的事务？
<img src="https://img-blog.csdnimg.cn/20181108114818618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbWluaWNKaQ==,size_16,color_FFFFFF,t_70" /><br />
Redis的事务具有以下特点:<br />
**事务之全体连坐**<br />
在创建事务的时候，如果事务内有一行代码在创建的时候就已经报错，那么整个事务都不会被执行<br />
**事务之冤头债主**<br />
在创建事务的时候，代码都没有报错，但是在执行阶段有几个语句无法操作，比如你的语句是让值加一，然而值是字符串类型，没法加一，这个时候所有不报错的语句都会执行成功，只有那些执行阶段报错的语句不会执行成功原因:redis是部分支持事务，不像传统的数据库对事务是强一致性的要求
##### 7. Redis 的使用场景有哪些？
<ol>
- 取最新 N 个数据的操作
- 排行榜应用,取 TOP N 操作
- 需要精准设定过期时间的应用
- 计数器应用
- uniq 操作,获取某段时间所有数据排重值
- Pub/Sub 构建实时消息系统
- 构建队列系统
- 缓存
</ol>
##### 8. Redis 默认端口，默认过期时间，Value 最多可以容纳的数据 长度？
<ol>
- 默认端口：6379 (补充:大家应该知道常用数据库的默认端口都是多少Redis:6379,MySQL:3306，<a href="MongoDB:27017" class="uri">MongoDB:27017</a>)
- 默认过期时间：可以说永不过期，一般情况下，当配置中开启 了超出最大内存限制就写磁盘的话，那么没有设置过期时间的 key 可能会被写到磁盘上。假如没设置，那么 REDIS 将使用 LRU 机制，将 内存中的老数据删除，并写入新数据。
- Value 最多可以容纳的数据长度是：512M。
</ol>
##### 9. Redis 有多少个库？
Redis自带有16个库，默认情况下是0库，可通过select选择相同的库，一般情况下都只使用0号库，其他库一般都用不到
##### 10.redis 和 memcached 的区别?
```python
1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；

2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；

3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；

4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；

5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；

6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；

7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；

8、Redis支持数据的备份，即master-slave模式的数据备份；

```
##### 11.如何高效的找到redis中所有以"xxx"开头的key?
```python
redis 有一个keys命令。
# 语法：KEYS pattern
# 说明：返回与指定模式相匹配的所用的keys。
该命令所支持的匹配模式如下：
1、?：用于匹配单个字符。例如，h?llo可以匹配hello、hallo和hxllo等；
2、*：用于匹配零个或者多个字符。例如，h*llo可以匹配hllo和heeeello等；
2、[]：可以用来指定模式的选择区间。例如h[ae]llo可以匹配hello和hallo，但是不能匹配hillo。同时，可以使用“/”符号来转义特殊的字符
# 注意
KEYS 的速度非常快，但如果数据太大，内存可能会崩掉，
如果需要从一个数据集中查找特定的key，最好还是用Redis的集合结构(set)来代替。

```
##### 12.什么是一致性哈希?
```python
一致性哈希
一致性hash算法（DHT）可以通过减少影响范围的方式，解决增减服务器导致的数据散列问题，从而解决了分布式环境下负载均衡问题；
如果存在热点数据，可以通过增添节点的方式，对热点区间进行划分，将压力分配至其他服务器，重新达到负载均衡的状态。
Python模块--hash_ring，即Python中的一致性hash

```
##### 13.redis 是单进程单线程的吗?
```python
redis内部是单进程、单线程，是数据安全的

```
##### 14.redis 中数据库默认是多少个 db 及作用?
```python
Redis默认支持16个数据库，可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库
  
Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。

```
##### 15.如果redis中的某个列表中的数据量非常大，如果实现循环显示每一个 值?
```python
# 如果一个列表在redis中保存了10w个值，我需要将所有值全部循环并显示，请问如何实现？
# 一个一个取值，列表没有iter方法，但能自定义
def list_scan_iter(name,count=3):
    start = 0
    while True:
        result = conn.lrange(name, start, start+count-1)  # Lrange 返回列表中指定区间内的元素

        start += count
        if not result:
            break
        for item in result:
            yield item

for val in list_scan_iter('num_list'):
    print(val)
# 场景：投票系统，script-redis

```
##### 16.redis 如何实现主从复制?以及数据同步机制?
```python
优势：
    - 高可用
    - 分担主压力
注意： 
    - slave设置只读

从的配置文件添加以下记录，即可：
`slaveof 1.1.1.1 3306`

```
##### 17.redis 中的 sentinel 的作用?
```python
帮助我们自动在主从之间进行切换
检测主从中 主是否挂掉，且超过一半的sentinel检测到挂了之后才进行进行切换。
如果主修复好了，再次启动时候，会变成从。

启动主redis:
redis-server /etc/redis-6379.conf  启动主redis
redis-server /etc/redis-6380.conf  启动从redis
        
在linux中：
找到 /etc/redis-sentinel-8001.conf  配置文件，在内部：
    - 哨兵的端口 port = 8001
    - 主redis的IP，哨兵个数的一半/1
        
找到 /etc/redis-sentinel-8002.conf  配置文件，在内部：
    - 哨兵的端口 port = 8002
    - 主redis的IP, 1 
启动两个哨兵   

```
##### 18.如何实现redis集群?
```python
"""
- 官方cluster方案
- twemproxy代理方案
- 哨兵模式
- codis
- 客户端分片
"""
官方cluster方案:
从redis 3.0版本开始支持redis-cluster集群，redis-cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他节点连接。redis-cluster是一种服务端分片技术。

twemproxy代理方案:
Redis代理中间件twemproxy是一种利用中间件做分片的技术。twemproxy处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后（sharding），再转发给后端真正的redis服务器。也就是说，客户端不直接访问redis服务器，而是通过twemproxy代理中间件间接访问。降低了客户端直连后端服务器的连接数量，并且支持服务器集群水平扩展。

哨兵模式:
Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。

codis:
codis是一个分布式的Redis解决方案，由豌豆荚开源，对于上层的应用来说，连接codis proxy和连接原生的redis server没什么明显的区别，上层应用可以像使用单机的redis一样使用，codis底层会处理请求的转发，不停机的数据迁移等工作，所有后边的事情，对于前面的客户端来说是透明的，可以简单的认为后边连接的是一个内存无限大的redis服务。

客户端分片:
分区的逻辑在客户端实现，由客户端自己选择请求到哪个节点。方案可参考一致性哈希，这种方案通常适用于用户对客户端的行为有完全控制能力的场景。

```
##### 19.redis 中默认有多少个哈希槽?
1384
##### 20.简述redis的有哪几种持久化策略及比较?
```python
RDB：每隔一段时间对redis进行一次持久化。
      - 缺点：数据不完整
      - 优点：速度快
AOF：把所有命令保存起来，如果想到重新生成到redis，那么就要把命令重新执行一次。
      - 缺点：速度慢，文件比较大
      - 优点：数据完整

```
##### 21.列举redis支持的过期策略。
```python
voltile-lru：    从已设置过期时间的数据集（server.db[i].expires）中挑选最近频率最少数据淘汰
volatile-ttl：   从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

  
allkeys-lru：       从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：    从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据

```
##### 22.如何基于redis实现消息队列?
```python
# 通过发布订阅模式的PUB、SUB实现消息队列
# 发布者发布消息到频道了，频道就是一个消息队列。
# 发布者：
import redis
conn = redis.Redis(host='127.0.0.1',port=6379)
conn.publish('104.9MH', "hahahahahaha")
# 订阅者：
import redis
conn = redis.Redis(host='127.0.0.1',port=6379)
pub = conn.pubsub()
pub.subscribe('104.9MH')
while True:
    msg= pub.parse_response()
    print(msg)
#对了，redis 做消息队列不合适
#业务上避免过度复用一个redis，用它做缓存、做计算，还做任务队列，压力太大，不好。

```
##### 23.如何基于redis实现发布和订阅?
```python
#发布和订阅，只要有任务就给所有订阅者没人一份
#发布者：
import redis

conn = redis.Redis(host='127.0.0.1',port=6379)
conn.publish('104.9MH', "hahaha")

#订阅者：
import redis

conn = redis.Redis(host='127.0.0.1',port=6379)
pub = conn.pubsub()
pub.subscribe('104.9MH')

while True:
    msg= pub.parse_response()
    print(msg)

```
##### 24.简述redis分布式锁和redlock的实现机制。
```python
'''
在不同进程需要互斥地访问共享资源时，分布式锁是一种非常有用的技术手段。
有很多三方库和文章描述如何用Redis实现一个分布式锁管理器，但是这些库实现的方式差别很大
，而且很多简单的实现其实只需采用稍微增加一点复杂的设计就可以获得更好的可靠性。
用Redis实现分布式锁管理器的算法，我们把这个算法称为RedLock。

实现
- 写值并设置超时时间
- 超过一半的redis实例设置成功，就表示加锁完成。
- 使用：安装redlock-py
'''

from redlock import Redlock

dlm = Redlock(
    [
        {"host": "localhost", "port": 6379, "db": 0},
        {"host": "localhost", "port": 6379, "db": 0},
        {"host": "localhost", "port": 6379, "db": 0},
    ]
)

# 加锁，acquire
my_lock = dlm.lock("my_resource_name",10000)
if  my_lock:
    # J进行操作
    # 解锁,release
    dlm.unlock(my_lock)
else:
    print('获取锁失败')
# redis分布式锁？
# 不是单机操作，又多了一/多台机器
# redis内部是单进程、单线程，是数据安全的(只有自己的线程在操作数据)

```
##### 25.写代码，基于redis的列表实现先进先出、后进先出队列、优先级队列。
```python
# 参看script—redis源码
from scrapy.utils.reqser import request_to_dict, request_from_dict

from . import picklecompat


class Base(object):
    """Per-spider base queue class"""

    def __init__(self, server, spider, key, serializer=None):
        """Initialize per-spider redis queue.

        Parameters
        ----------
        server : StrictRedis
            Redis client instance.
        spider : Spider
            Scrapy spider instance.
        key: str
            Redis key where to put and get messages.
        serializer : object
            Serializer object with ``loads`` and ``dumps`` methods.

        """
        if serializer is None:
            # Backward compatibility.
            # TODO: deprecate pickle.
            serializer = picklecompat
        if not hasattr(serializer, 'loads'):
            raise TypeError("serializer does not implement 'loads' function: %r"
                            % serializer)
        if not hasattr(serializer, 'dumps'):
            raise TypeError("serializer '%s' does not implement 'dumps' function: %r"
                            % serializer)

        self.server = server
        self.spider = spider
        self.key = key % {'spider': spider.name}
        self.serializer = serializer

    def _encode_request(self, request):
        """Encode a request object"""
        obj = request_to_dict(request, self.spider)
        return self.serializer.dumps(obj)

    def _decode_request(self, encoded_request):
        """Decode an request previously encoded"""
        obj = self.serializer.loads(encoded_request)
        return request_from_dict(obj, self.spider)

    def __len__(self):
        """Return the length of the queue"""
        raise NotImplementedError

    def push(self, request):
        """Push a request"""
        raise NotImplementedError

    def pop(self, timeout=0):
        """Pop a request"""
        raise NotImplementedError

    def clear(self):
        """Clear queue/stack"""
        self.server.delete(self.key)


class FifoQueue(Base):
    """Per-spider FIFO queue"""

    def __len__(self):
        """Return the length of the queue"""
        return self.server.llen(self.key)

    def push(self, request):
        """Push a request"""
        self.server.lpush(self.key, self._encode_request(request))

    def pop(self, timeout=0):
        """Pop a request"""
        if timeout > 0:
            data = self.server.brpop(self.key, timeout)
            if isinstance(data, tuple):
                data = data[1]
        else:
            data = self.server.rpop(self.key)
        if data:
            return self._decode_request(data)


class PriorityQueue(Base):
    """Per-spider priority queue abstraction using redis' sorted set"""

    def __len__(self):
        """Return the length of the queue"""
        return self.server.zcard(self.key)

    def push(self, request):
        """Push a request"""
        data = self._encode_request(request)
        score = -request.priority
        # We don't use zadd method as the order of arguments change depending on
        # whether the class is Redis or StrictRedis, and the option of using
        # kwargs only accepts strings, not bytes.
        self.server.execute_command('ZADD', self.key, score, data)

    def pop(self, timeout=0):
        """
        Pop a request
        timeout not support in this queue class
        """
        # use atomic range/remove using multi/exec
        pipe = self.server.pipeline()
        pipe.multi()
        pipe.zrange(self.key, 0, 0).zremrangebyrank(self.key, 0, 0)
        results, count = pipe.execute()
        if results:
            return self._decode_request(results[0])


class LifoQueue(Base):
    """Per-spider LIFO queue."""

    def __len__(self):
        """Return the length of the stack"""
        return self.server.llen(self.key)

    def push(self, request):
        """Push a request"""
        self.server.lpush(self.key, self._encode_request(request))

    def pop(self, timeout=0):
        """Pop a request"""
        if timeout > 0:
            data = self.server.blpop(self.key, timeout)
            if isinstance(data, tuple):
                data = data[1]
        else:
            data = self.server.lpop(self.key)

        if data:
            return self._decode_request(data)


# TODO: Deprecate the use of these names.
SpiderQueue = FifoQueue
SpiderStack = LifoQueue
SpiderPriorityQueue = PriorityQueue

```
##### 26.什么是codis?
```python
Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 (有一些命令不支持), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务，当然，前段时间redis官方的3.0出了稳定版，3.0支持集群功能，codis的实现原理和3.0的集群功能差不多。

```
##### 27.什么是twemproxy?
```python
Twemproxy是一种代理分片机制，由Twitter开源。Twemproxy作为代理，可接受来自多个程序的访问，按照路由规则，转发给后台的各个Redis服务器，再原路返回。该方案很好的解决了单个Redis实例承载能力的问题。当然，Twemproxy本身也是单点，需要用Keepalived做高可用方案。通过Twemproxy可以使用多台服务器来水平扩张redis服务，可以有效的避免单点故障问题。虽然使用Twemproxy需要更多的硬件资源和在redis性能有一定的损失（twitter测试约20%），但是能够提高整个系统的HA也是相当划算的。不熟悉twemproxy的同学，如果玩过nginx反向代理或者mysql proxy，那么你肯定也懂twemproxy了。其实twemproxy不光实现了redis协议，还实现了memcached协议，什么意思？换句话说，twemproxy不光可以代理redis，还可以代理memcached

```
##### 28.redis 如何实现事务。
```python
简单理解，可以认为redis事务是一些列redis命令的集合，并且有如下两个特点：
a）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
b）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

########################## python实现redis事务 ###########################
import redis

pool = redis.ConnectionPool(host='10.211.55.4', port=6379)

conn = redis.Redis(connection_pool=pool)

# pipe = r.pipeline(transaction=False)
pipe = conn.pipeline(transaction=True)
# 开始事务
pipe.multi()

pipe.set('name', 'bendere')
pipe.set('role', 'sb')

# 提交
pipe.execute()

```
##### 29.redis 中的 watch 的命令的作用?
```python
WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。

被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。

import redis

conn = redis.Redis(host='127.0.0.1', port=6379)

# conn.set('count',1000)
val = conn.get('count')
print(val)

with conn.pipeline(transaction=True) as pipe:
    # 先监视，自己的值没有被修改过
    conn.watch('count')

    # 事务开始
    pipe.multi()
    old_count = conn.get('count')
    count = int(old_count)
    print('现在剩余的商品有:%s', count)
    input("问媳妇让不让买？")
    pipe.set('count', count - 1)

    # 执行，把所有命令一次性推送过去
    pipe.execute()

```
##### 30.请设计一个商城商品计数器的实现方案?
```python
import redis

conn = redis.Redis(host='192.168.1.41',port=6379)

conn.set('count',1000)

with conn.pipeline() as pipe:

    # 先监视，自己的值没有被修改过
    conn.watch('count')

    # 事务开始
    pipe.multi()
    old_count = conn.get('count')
    count = int(old_count)
    if count > 0:  # 有库存
        pipe.set('count', count - 1)

    # 执行，把所有命令一次性推送过去
    pipe.execute()

```
##### 31.MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中都 是热点数据?
```python
#1 
限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。
所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。

redis 提供 6种数据淘汰策略：
voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据

```
##### 