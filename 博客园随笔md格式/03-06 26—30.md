## 26.有A.txt和B.txt两个文件, 使用多进程和进程池的方式分别读取这两个文件
```python
# 答案:
# 多进程
"""通过多进程加速读取excel的测试"""
__author__ = "hanyaning@deri.energy"
import os.path
import time
from service import logger
import pandas as pd
from multiprocessing import Process, Manager
startTime = time.time()

logger = logger.MyLogger("multi_process").getLogger()


def getExcelData(path, return_data=None, file_name=""):
    global startTime
    logger.info("开始读取Excel文件，当前进程pid：" + str(os.getpid()))
    if not os.path.exists(path):
        raise FileNotFoundError()
    if os.path.isfile(path):
        return_data[file_name] = pd.read_excel(path, skiprows=1, skipfooter=1)
        logger.info("读取Excel文件完毕，当前进程pid：" + str(os.getpid()))

if __name__ == "__main__":
    excel_path = os.path.join(os.getcwd(), "../excels")
    xls_names = [x for x in os.listdir(excel_path) if x.endswith(".xls")]
    first = str(time.time() - startTime)
    logger.info("进入程序用时：" + first)
    p_list = []
    # Manager类似于同步数据管理工具，可在多进程时实现各进程操作同一个数据，比如这里通过它组织返回值
    manager = Manager()
    # Manager.dict()类似于共享变量，各个进程可以修改它，通过每次添加不同的key值，可以实现方法返回值的获取
    return_data = manager.dict()
    first = time.time() - startTime
    # 手动创建多个进程读取，可能存在创建进程过多导致系统崩溃的情况
    for file_name in xls_names:
        p = Process(target=getExcelData, args=(os.path.join(excel_path, file_name), return_data, file_name))
        p.start()
        p_list.append(p)
    print(p_list)

    """
    经测试，直到这里都还会延迟数秒才执行进程的target方法，尽管前面已经调用了start(),但进程并没有立即执行
    寡人认为是系统创建进程需要时间，并且是创建好所有进程后才各进程才开始工作，这里要创建120个进程花费了大多数的时间
    后面在采用进程池时，当设置最大进程数为120时，依然花费了大把的时间，而设置为10时，大大缩小了创建进程到执行target方法所要等待的时间
    这也证明了寡人的观点，至于正确与否，寡人先跟代码去了，且等下回分解
    """
    for p in p_list:
        # 如果有子进程没有执行完，需要先阻塞主进程
        p.join()
    logger.info("各进程执行完毕")
    # 获取返回值字典为列表
    data_frames = return_data.values()
    # 合并列表为一个dataFrame
    data = pd.DataFrame()

    for da in data_frames:
        data = data.append(da)

    endTime = time.time()
    print(endTime - startTime)
    print(len(data))


# 进程池
"""通过多进程加速读取excel的测试"""
__author__ = "hanyaning@deri.energy"
import os.path
import time
from service import logger
import pandas as pd
from multiprocessing import Pool

logger = logger.MyLogger("multi_process").getLogger()


def getExcelData(path):
    logger.info("开始读取excel，当前进程pid：" + str(os.getpid()))
    data = pd.DataFrame()
    if not os.path.exists(path):
        raise FileNotFoundError()
    if os.path.isfile(path):
        logger.info("读取Excel文件完毕，当前进程pid：" + str(os.getpid()))
    return data.append(pd.read_excel(path, skiprows=1, skipfooter=1), sort=False)


if __name__ == "__main__":
    excel_path = os.path.join(os.getcwd(), "../excels")
    xls_names = [x for x in os.listdir(excel_path) if x.endswith(".xls")]
    startTime = time.time()

    p_list = []
    # 使用进程池Pool
    pool = Pool(processes=10)
    pool_data_list = []
    data = pd.DataFrame()
    for file_name in xls_names:
        # 需要注意不能直接在这里调用get方法获取数据,原因是apply_async后面 get()等待线程运行结束才会下一个,这里多进程会变成阻塞执行
        pool_data_list.append(pool.apply_async(getExcelData, (os.path.join(excel_path, file_name),)))
    pool.close()
    # 需要阻塞以下，等所有子进程执行完毕后主线程才继续执行
    pool.join()
    for pool_data in pool_data_list:
        # 这里再使用get()方法可以获取返回值
        data = data.append(pool_data.get())
    endTime = time.time()
    print(endTime - startTime)
    print(len(data))

```
## 27.以下那些是常见的TCPFlags?(多选)
```python
'''
A.SYN
B.RST
C.ACK
D.URG
'''
# 答案:
'''
A,B,C,D
'''
```
## 28.下面关于网络七层和四层的􏰀述, 哪条是错误的?
```python
'''
A.SNMP工作在四层
B.四层是指网络的传输层, 主要包括IP和端口信息
C.七层是指网络的应用层(协议层), 比如http协议就工作在七层
D.四层主要应用于TCP和UDP的代理, 七层主要应用于HTTP等协议的代理
'''

# 答案:
A
```
## 29.tracerroute一般使用的是哪种网络层协议
```python
'''
A.VRRP
B.UDP
C.ARP
D.ICMP
'''

# 答案:
D
```
## 30.iptables知识考察, 根据要求写出防火墙规则?
```python
'''
A.屏蔽192.168.1.5访问本机dns服务端口
B.允许10.1..0/2访问本机的udp88889999端口
'''
# 答案:
'''
iptables -A INPUT -p ICMP --icmp-type 8 -m time --timestart 00:00:00 --timestop 23:59:59 --weekdays Mon -j DROP
'''
```